library(RSP)
?runRSP
setwd("..")
water <- actel::loadShape(path = system.file(package = "RSP"),
shape = "River_latlon.shp", size = 0.0001, buffer = 0.05)
tl <- actel::transitionLayer(x = water, directions = 8)
data(input.example)
input = input.example
t.layer = tl
coord.x = "Longitude"
coord.y = "Latitude"
if (debug) {#
    on.exit(save(list = ls(), file = "RSP_debug.RData"), add = TRUE)#
    message("!!!--- Debug mode has been activated ---!!!")#
  }
distance = 250
recaptures = FALSE
time.step = 10
min.time = 10
max.time = 24
verbose = FALSE
debug = FALSE
if (debug) {#
    on.exit(save(list = ls(), file = "RSP_debug.RData"), add = TRUE)#
    message("!!!--- Debug mode has been activated ---!!!")#
  }
if (is.null(input$rsp.info))
stop("'input' could not be recognised as an actel analysis result.\n", call. = FALSE)
if (missing(er.ad))
er.ad <- distance * 0.05
if (time.step > min.time)
warning("'time.step' should not be larger than 'min.time'.", call. = FALSE, immediate. = TRUE)
if (recaptures == TRUE) {#
    if ("recaptures.csv" %in% list.files()){#
      recap <- read.csv("recaptures.csv")#
    } else {#
      stop("Missing 'recaptures.csv' file. Please provide the data or set recaptures = FALSE")#
    }#
  }
message("M: Calculating RSP for the '", input$rsp.info$analysis.type, "' data compiled on ", input$rsp.info$analysis.time)
detections <- input$valid.detections
spatial <- input$spatial
tz <- input$rsp.info$tz
if (!missing(tags)) {#
    if(any(link <- is.na(match(tags, names(detections)))))#
      stop("Could not find tag(s) ", paste(tags[link], collapse = ", ") , " in the detection data.", call. = FALSE)#
#
    detections <- detections[match(tags, names(detections))]#
  }
detections = detections
spatial = spatial
coord.x = coord.x
coord.y = coord.y
if (!any(colnames(spatial$stations) == "Range"))
warning("Could not find a 'Range' column in the spatial data; assuming a range of 500 metres for each receiver.", immediate. = TRUE, call. = FALSE)
i<-1
x <- detections[[i]]
x
if (length(unique(x$Transmitter)) > 1)
x$Transmitter <- rep(i, nrow(x))
x$Date <- as.Date(x$Timestamp)
if (any(colnames(spatial$stations) == "Range")) {#
      link <- match(x$Standard.name, spatial$stations$Standard.name)#
      x$Error <- spatial$stations$Range[link]#
    } else {#
      x$Error <- 500#
    }
x$Time.lapse.min <- c(0, as.numeric(difftime(x$Timestamp[-1], x$Timestamp[-nrow(x)], units = "mins")))
x$Longitude <- spatial$stations[[coord.x]][match(x$Standard.name, spatial$stations$Standard.name)]
x$Latitude <- spatial$stations[[coord.y]][match(x$Standard.name, spatial$stations$Standard.name)]
x$Position <- "Receiver"
head(x)
prepareDetections <- function(detections, spatial, coord.x, coord.y) {#
  if (!any(colnames(spatial$stations) == "Range")) #
    warning("Could not find a 'Range' column in the spatial data; assuming a range of 500 metres for each receiver.", immediate. = TRUE, call. = FALSE)#
#
  output <- lapply(names(detections), function(i){#
    x <- detections[[i]]#
    if (length(unique(x$Transmitter)) > 1)#
      x$Transmitter <- rep(i, nrow(x))#
    x$Date <- as.Date(x$Timestamp)#
    if (any(colnames(spatial$stations) == "Range")) {#
      link <- match(x$Standard.name, spatial$stations$Standard.name)#
      x$Error <- spatial$stations$Range[link]#
    } else {#
      x$Error <- 500#
    }#
    x$Time.lapse.min <- c(0, as.numeric(difftime(x$Timestamp[-1], x$Timestamp[-nrow(x)], units = "mins")))#
    x$Longitude <- spatial$stations[[coord.x]][match(x$Standard.name, spatial$stations$Standard.name)]#
    x$Latitude <- spatial$stations[[coord.y]][match(x$Standard.name, spatial$stations$Standard.name)]#
    x$Position <- "Receiver"#
    return(x)#
  })#
  names(output) <- names(detections)#
  return(output)#
}
detections <- prepareDetections(detections = detections, #
    spatial = spatial, coord.x = coord.x, coord.y = coord.y)
RSP.time <- system.time(recipient <- includeRSP(detections = detections, transition = t.layer, max.time = max.time, min.time = min.time, recaptures = recaptures,#
                                           tz = tz, distance = distance, time.step = time.step, er.ad = er.ad, verbose = verbose, debug = debug))
prepareDetections <- function(detections, spatial, coord.x, coord.y) {#
  if (!any(colnames(spatial$stations) == "Range")) #
    warning("Could not find a 'Range' column in the spatial data; assuming a range of 500 metres for each receiver.", immediate. = TRUE, call. = FALSE)#
#
  output <- lapply(names(detections), function(i){#
    x <- detections[[i]]#
    if (length(unique(x$Transmitter)) > 1)#
      x$Transmitter <- rep(i, nrow(x))#
    x$Date <- as.Date(x$Timestamp)#
    if (any(colnames(spatial$stations) == "Range")) {#
      link <- match(x$Standard.name, spatial$stations$Standard.name)#
      x$Error <- spatial$stations$Range[link]#
    } else {#
      x$Error <- 500#
    }#
    x$Time.lapse.min <- c(0, as.numeric(difftime(x$Timestamp[-1], x$Timestamp[-nrow(x)], units = "mins")))#
    x$Longitude <- spatial$stations[[coord.x]][match(x$Standard.name, spatial$stations$Standard.name)]#
    x$Latitude <- spatial$stations[[coord.y]][match(x$Standard.name, spatial$stations$Standard.name)]#
    x$Position <- "Receiver"#
    return(x)#
  })#
  names(output) <- names(detections)#
  return(output)#
}
detections <- prepareDetections(detections = detections, #
    spatial = spatial, coord.x = coord.x, coord.y = coord.y)
includeRSP <- function(detections, transition, tz, distance, time.step, er.ad, min.time, max.time, verbose, debug = FALSE, recaptures) {#
  if (debug)#
    on.exit(save(list = ls(), file = "includeRSP_debug.RData"), add = TRUE)#
  path.list <- list() # Empty list to save already calculated paths#
#
  if (!verbose)#
      pb <- txtProgressBar(min = 0, max = length(detections),#
                            initial = 0, style = 3, width = 60)#
#
  # Recreate RSP individually#
  aux <- lapply(seq_along(detections), function(i) {#
    if (verbose)#
      message(crayon::bold(crayon::green((paste("Analysing:", names(detections)[i])))))#
    flush.console()#
    recipient <- nameTracks(detections = detections[[i]], max.time = max.time, recaptures = recaptures, tz = tz) # Fine-scale tracking#
    detections[[i]] <<- recipient$detections#
    tracks <- recipient$tracks#
    track.aux <- split(detections[[i]], detections[[i]]$Track)#
#
    tag.aux <- lapply(which(tracks$Valid), function(j) {#
      if (verbose)#
        message("Estimating ", names(detections)[i], " RSP: ", names(track.aux)[j])#
      flush.console()#
      # Recreate RSP#
      df.track <- track.aux[[j]]#
      df.track$Time.lapse.min <- c(0, as.numeric(difftime(df.track$Timestamp[-1], df.track$Timestamp[-nrow(df.track)], units = "mins")))#
      function.recipient <- calcRSP(df.track = df.track, tz = tz, distance = distance, verbose = verbose, min.time = min.time,#
                                    time.step = time.step, transition = transition, er.ad = er.ad, path.list = path.list)#
      # return path.list directly to environment above#
      path.list <<- function.recipient$path.list#
#
      # return rest to lapply list#
      return(function.recipient$output)#
    })#
    # update track n#
    tracks$new.n[which(tracks$Valid)] <- sapply(tag.aux, nrow)#
#
    # combine tracks#
    tag.recipient <- as.data.frame(data.table::rbindlist(tag.aux))#
#
    # pass path.list to main envir.#
    path.list <<- path.list#
#
    # Convert variables to factors#
    tag.recipient$Position <- as.factor(tag.recipient$Position)#
    tag.recipient$Track <- as.factor(tag.recipient$Track)#
    tag.recipient$Receiver <- as.factor(tag.recipient$Receiver)#
    tag.recipient$Transmitter <- as.factor(tag.recipient$Transmitter)#
    tag.recipient$Standard.name <- as.factor(tag.recipient$Standard.name)#
    tag.recipient <- tag.recipient[order(tag.recipient$Timestamp), ]#
#
    if (!verbose)#
      setTxtProgressBar(pb, i) # Progress bar#
#
    return(list(detections = tag.recipient, tracks = tracks))#
  })#
  if (!verbose)#
    close(pb)    #
  output <- lapply(aux, function(x) x$detections)#
  tracks <- lapply(aux, function(x) x$tracks)#
  names(output) <- names(detections)#
  names(tracks) <- names(detections)#
  return(list(output = output, tracks = tracks))#
}
detections = detections
transition = t.layer
max.time = max.time
min.time = min.time
recaptures = recaptures
tz = tz
distance = distance
time.step = time.step
er.ad = er.ad
verbose = verbose
debug = debug
distance * 0.05
er.ad <- distance * 0.05
i<-1
if (verbose)
message(crayon::bold(crayon::green((paste("Analysing:", names(detections)[i])))))
flush.console()
recipient <- nameTracks(detections = detections[[i]], max.time = max.time, recaptures = recaptures, tz = tz) # Fine-scale tracking
nameTracks <- function(detections, max.time = 24, recaptures, tz) {#
  # Assign tracks to detections#
  if (recaptures == FALSE)#
      breaks <- which(detections$Time.lapse.min > max.time * 60)#
#
  if (recaptures == TRUE) {#
    recap <- read.csv("recaptures.csv")#
    if (detections$Signal[1] %in% recap$Signal) {#
      aux.recap <- recap[which(recap$Signal == detections$Signal[1]), ] #
      detections.aux <- detections[1:nrow(aux.recap), ] # Auxiliar to merge recaptures to detection data!#
      detections.aux$Receiver <- NA#
      detections.aux$Standard.name <- "Recapture"#
      detections.aux$Position <- "Recapture"#
      detections.aux$Error <- min(detections$Error) # Reset to minimum default error!#
      detections.aux$Array <- NA#
      detections.aux$Latitude <- aux.recap$Latitude#
      detections.aux$Longitude <- aux.recap$Longitude#
      detections.aux$Timestamp <- as.POSIXct(aux.recap$Recapture.date, format = "%Y-%m-%d %H:%M:%S", tz = tz) #
      detections.aux$Date <- as.Date(detections.aux$Timestamp)#
      detections <- rbind(detections, detections.aux)#
      detections <- detections[order(detections$Timestamp), ]#
      detections$Time.lapse.min <- c(0, as.numeric(difftime(detections$Timestamp[-1], detections$Timestamp[-nrow(detections)], units = "mins")))#
      breaks <- which(detections$Time.lapse.min > max.time * 60 | detections$Position == "Recapture")#
    } else {#
      breaks <- which(detections$Time.lapse.min > max.time * 60)#
    }#
  }#
  starts <- c(1, breaks)#
  stops  <- c(breaks, nrow(detections) + 1)#
  n <- (stops - starts)#
  track.index <- paste0("Track_", unlist(lapply(1:length(n), function(i) {#
    stringr::str_pad(string = rep(i, n[i]), width = nchar(length(n)), pad = "0")#
  })))#
  detections$Track <- track.index#
#
  # Create tracks summary#
  aux <- split(detections, detections$Track)#
  track.aux <- lapply(aux, function(x) {#
    data.frame(Track = NA_character_,#
      original.n = nrow(x),#
      new.n = nrow(x),#
      First.time = x$Timestamp[1],#
      Last.time = x$Timestamp[nrow(x)],#
      Timespan = difftime(x$Timestamp[nrow(x)], x$Timestamp[1], units = "hours"),#
      Valid = nrow(x) > 1#
      )#
  })#
  tracks <- data.table::rbindlist(track.aux)#
  tracks$Track <- names(aux)#
#
  if (any(!tracks$Valid)) {#
    invalid.tracks <- tracks$Track[which(!tracks$Valid)]#
    detections$Valid[grepl(paste(invalid.tracks, collapse = "|"), detections$Track)] <- FALSE#
  }#
#
  return(list(detections = detections, tracks = tracks))#
}
detections = detections[[i]]
max.time = max.time
recaptures = recaptures
tz = tz
max.time = 24
detections$Signal[1] %in% recap$Signal
recaptures == FALSE
breaks <- which(detections$Time.lapse.min > max.time * 60)
starts <- c(1, breaks)
stops  <- c(breaks, nrow(detections) + 1)
n <- (stops - starts)
track.index <- paste0("Track_", unlist(lapply(1:length(n), function(i) {#
    stringr::str_pad(string = rep(i, n[i]), width = nchar(length(n)), pad = "0")#
  })))
detections$Track <- track.index
aux <- split(detections, detections$Track)
head(aux)
paste(x$CodeSpace, x$Signal, sep = "-")
aux <- split(detections, detections$Track)
track.aux <- lapply(aux, function(x) {#
    data.frame(Transmitter = paste(x$CodeSpace, x$Signal, sep = "-"),#
      Track = NA_character_,#
      original.n = nrow(x),#
      new.n = nrow(x),#
      First.time = x$Timestamp[1],#
      Last.time = x$Timestamp[nrow(x)],#
      Timespan = difftime(x$Timestamp[nrow(x)], x$Timestamp[1], units = "hours"),#
      Valid = nrow(x) > 1#
      )#
  })
aux <- split(detections, detections$Track)
track.aux <- lapply(aux, function(x) {#
    data.frame(Transmitter = paste(x$CodeSpace[1], x$Signal[1], sep = "-"),#
      Track = NA_character_,#
      original.n = nrow(x),#
      new.n = nrow(x),#
      First.time = x$Timestamp[1],#
      Last.time = x$Timestamp[nrow(x)],#
      Timespan = difftime(x$Timestamp[nrow(x)], x$Timestamp[1], units = "hours"),#
      Valid = nrow(x) > 1#
      )#
  })
tracks
data.table::rbindlist(track.aux)
nameTracks <- function(detections, max.time = 24, recaptures, tz) {#
  # Assign tracks to detections#
  if (recaptures == FALSE)#
      breaks <- which(detections$Time.lapse.min > max.time * 60)#
#
  if (recaptures == TRUE) {#
    recap <- read.csv("recaptures.csv")#
    if (detections$Signal[1] %in% recap$Signal) {#
      aux.recap <- recap[which(recap$Signal == detections$Signal[1]), ] #
      detections.aux <- detections[1:nrow(aux.recap), ] # Auxiliar to merge recaptures to detection data!#
      detections.aux$Receiver <- NA#
      detections.aux$Standard.name <- "Recapture"#
      detections.aux$Position <- "Recapture"#
      detections.aux$Error <- min(detections$Error) # Reset to minimum default error!#
      detections.aux$Array <- NA#
      detections.aux$Latitude <- aux.recap$Latitude#
      detections.aux$Longitude <- aux.recap$Longitude#
      detections.aux$Timestamp <- as.POSIXct(aux.recap$Recapture.date, format = "%Y-%m-%d %H:%M:%S", tz = tz) #
      detections.aux$Date <- as.Date(detections.aux$Timestamp)#
      detections <- rbind(detections, detections.aux)#
      detections <- detections[order(detections$Timestamp), ]#
      detections$Time.lapse.min <- c(0, as.numeric(difftime(detections$Timestamp[-1], detections$Timestamp[-nrow(detections)], units = "mins")))#
      breaks <- which(detections$Time.lapse.min > max.time * 60 | detections$Position == "Recapture")#
    } else {#
      breaks <- which(detections$Time.lapse.min > max.time * 60)#
    }#
  }#
  starts <- c(1, breaks)#
  stops  <- c(breaks, nrow(detections) + 1)#
  n <- (stops - starts)#
  track.index <- paste0("Track_", unlist(lapply(1:length(n), function(i) {#
    stringr::str_pad(string = rep(i, n[i]), width = nchar(length(n)), pad = "0")#
  })))#
  detections$Track <- track.index#
#
  # Create tracks summary#
  aux <- split(detections, detections$Track)#
  track.aux <- lapply(aux, function(x) {#
    data.frame(Transmitter = paste(x$CodeSpace[1], x$Signal[1], sep = "-"),#
      Track = NA_character_,#
      original.n = nrow(x),#
      new.n = nrow(x),#
      First.time = x$Timestamp[1],#
      Last.time = x$Timestamp[nrow(x)],#
      Timespan = difftime(x$Timestamp[nrow(x)], x$Timestamp[1], units = "hours"),#
      Valid = nrow(x) > 1#
      )#
  })#
  tracks <- data.table::rbindlist(track.aux)#
  tracks$Track <- names(aux)#
#
  if (any(!tracks$Valid)) {#
    invalid.tracks <- tracks$Track[which(!tracks$Valid)]#
    detections$Valid[grepl(paste(invalid.tracks, collapse = "|"), detections$Track)] <- FALSE#
  }#
#
  return(list(detections = detections, tracks = tracks))#
}
includeRSP <- function(detections, transition, tz, distance, time.step, er.ad, min.time, max.time, verbose, debug = FALSE, recaptures) {#
  if (debug)#
    on.exit(save(list = ls(), file = "includeRSP_debug.RData"), add = TRUE)#
  path.list <- list() # Empty list to save already calculated paths#
#
  if (!verbose)#
      pb <- txtProgressBar(min = 0, max = length(detections),#
                            initial = 0, style = 3, width = 60)#
#
  # Recreate RSP individually#
  aux <- lapply(seq_along(detections), function(i) {#
    if (verbose)#
      message(crayon::bold(crayon::green((paste("Analysing:", names(detections)[i])))))#
    flush.console()#
    recipient <- nameTracks(detections = detections[[i]], max.time = max.time, recaptures = recaptures, tz = tz) # Fine-scale tracking#
    detections[[i]] <<- recipient$detections#
    tracks <- recipient$tracks#
    track.aux <- split(detections[[i]], detections[[i]]$Track)#
#
    tag.aux <- lapply(which(tracks$Valid), function(j) {#
      if (verbose)#
        message("Estimating ", names(detections)[i], " RSP: ", names(track.aux)[j])#
      flush.console()#
      # Recreate RSP#
      df.track <- track.aux[[j]]#
      df.track$Time.lapse.min <- c(0, as.numeric(difftime(df.track$Timestamp[-1], df.track$Timestamp[-nrow(df.track)], units = "mins")))#
      function.recipient <- calcRSP(df.track = df.track, tz = tz, distance = distance, verbose = verbose, min.time = min.time,#
                                    time.step = time.step, transition = transition, er.ad = er.ad, path.list = path.list)#
      # return path.list directly to environment above#
      path.list <<- function.recipient$path.list#
#
      # return rest to lapply list#
      return(function.recipient$output)#
    })#
    # update track n#
    tracks$new.n[which(tracks$Valid)] <- sapply(tag.aux, nrow)#
#
    # combine tracks#
    tag.recipient <- as.data.frame(data.table::rbindlist(tag.aux))#
#
    # pass path.list to main envir.#
    path.list <<- path.list#
#
    # Convert variables to factors#
    tag.recipient$Position <- as.factor(tag.recipient$Position)#
    tag.recipient$Track <- as.factor(tag.recipient$Track)#
    tag.recipient$Receiver <- as.factor(tag.recipient$Receiver)#
    tag.recipient$Transmitter <- as.factor(tag.recipient$Transmitter)#
    tag.recipient$Standard.name <- as.factor(tag.recipient$Standard.name)#
    tag.recipient <- tag.recipient[order(tag.recipient$Timestamp), ]#
#
    if (!verbose)#
      setTxtProgressBar(pb, i) # Progress bar#
#
    return(list(detections = tag.recipient, tracks = tracks))#
  })#
  if (!verbose)#
    close(pb)    #
  output <- lapply(aux, function(x) x$detections)#
  tracks <- lapply(aux, function(x) x$tracks)#
  names(output) <- names(detections)#
  names(tracks) <- names(detections)#
  return(list(output = output, tracks = tracks))#
}
RSP.time <- system.time(recipient <- includeRSP(detections = detections, transition = t.layer, max.time = max.time, min.time = min.time, recaptures = recaptures,#
                                           tz = tz, distance = distance, time.step = time.step, er.ad = er.ad, verbose = verbose, debug = debug))
install.packages("raster")
