#' Identify and remove duplicated timestamps#
#' #
#' @param input The detections to be checked#
#' @param group The group being analysed, used solely for messaging purposes#
#' #
#' @return The detections without duplicated timestamps#
#' #
#' @keywords internal#
#' #
checkDupTimestamps <- function(input, group, verbose = TRUE) {#
  index <- which(duplicated(input$Timestamp))#
  if (length(index) > 0) {#
    input <- input[-index, ]#
    if (verbose)#
      warning(length(index), " individual detections were removed in group ", group," due to simultaneous detections at two receivers.", immediate. = TRUE, call. = FALSE)#
  }#
  return(input)#
}#
#
#' Performs a series of quality checks on the detection data.#
#' #
#' @param input The detections list#
#' @inheritParams dynBBMM#
#' #
#' @return The detections which can be used for dbbmm#
#' #
#' @keywords internal#
#' #
checkGroupQuality <- function(input, verbose = TRUE) {#
  if (attributes(input)$type == "group") {#
    output <- lapply(names(input), function(i) {#
      outp <- checkDupTimestamps(input = input[[i]], group = i, verbose = verbose)#
      outp <- checkTrackPoints(input = outp, group = i, verbose = verbose)#
      if (!is.null(outp)) {#
        outp <- checkTrackTimes(input = outp, group = i, verbose = verbose)#
        return(outp)#
      } else {#
        return(NULL)#
      }#
    })#
    if (all(link <- unlist(lapply(output, is.null)))) {#
      stop("All detection data failed to pass the quality checks for dBBMM implementation. Aborting.\n", call. = FALSE)#
    }#
    names(output) <- names(input)#
    output <- output[!link]#
    attributes(output)$type <- "group"#
    return(output)#
  }#
#
  if (attributes(input)$type == "timeslot") {#
    output <- lapply(names(input), function(g) {#
      recipient <- lapply(names(input[[g]]), function(i) {#
        aux <- checkDupTimestamps(input = input[[g]][[i]], group = paste0(g, " (timeslot ", i, ")"), verbose = verbose)#
        aux <- checkTrackPoints(input = aux, group = paste0(g, " (timeslot ", i, ")"), verbose = verbose)#
        if (!is.null(aux)) {#
          aux <- checkTrackTimes(input = aux, group = paste0(g, " (timeslot ", i, ")"), verbose = verbose)#
          return(aux)#
        } else {#
          return(NULL)#
        }#
      })#
      names(recipient) <- names(input[[g]])#
      return(recipient[!unlist(lapply(recipient, is.null))])#
    })#
    if (all(link <- unlist(lapply(output, length)) == 0))#
      stop("All detection data failed to pass the quality checks for dBBMM implementation. Aborting.\n", call. = FALSE)#
    names(output) <- names(input)#
    output <- output[!link]#
    attributes(output)$type <- "timeslot"#
    return(output)#
  }#
}#
#
#' Exclude tracks with less than 8 detections#
#' #
#' @inheritParams checkDupTimestamps#
#' #
#' @return The detections for tracks with more than 8 detections#
#' #
#' @keywords internal#
#' #
checkTrackPoints <- function(input, group, verbose = TRUE) {#
  tracks <- split(input, input$ID)#
  link <- unlist(lapply(tracks, nrow)) > 8#
  if (all(!link)) {#
    if (verbose)#
      warning("ALL tracks in group ", group, " have less than eight detections. Removing group from analysis.", immediate. = TRUE, call. = FALSE)    #
    return(NULL)#
  } else {#
    output <- tracks[link]#
    if (verbose && length(tracks) > length(output))#
      warning(length(tracks) - length(output), " track(s) in group ", group, " have less than eight detections and will not be used.", immediate. = TRUE, call. = FALSE)#
    return(do.call(rbind.data.frame, output))#
  }#
}#
#
#' Exclude tracks shorter than 30 minutes:#
#' #
#' @inheritParams checkDupTimestamps#
#' #
#' @return The detections for tracks longer than 30 minutes#
#' #
#' @keywords internal#
#' #
checkTrackTimes <- function(input, group, verbose = TRUE) {#
  tracks <- split(input, input$ID)#
  link <- unlist(lapply(tracks, function(x) {#
    as.numeric(difftime(x$Timestamp[[nrow(x)]], x$Timestamp[[1]], units = "min"))#
  })) >= 30#
  if (all(!link)) {#
    if (verbose)#
      warning("ALL tracks in group ", group, " are shorter than 30 minutes. Removing group from analysis.", immediate. = TRUE, call. = FALSE)    #
    return(NULL)#
  } else {#
    output <- tracks[link]#
    if (verbose && length(tracks) > length(output))#
      warning(sum(!link), " track(s) in group ", group, " are shorter than 30 minutes and will not be used.", immediate. = TRUE, call. = FALSE)#
    return(do.call(rbind.data.frame, output))#
  }#
}
#' Split detections every time "timeframe" hours pass.#
#' #
#' @param input a list of detections per group#
#' @param timerange the time-range over which detections are to be used#
#' @param timeframe the interval of hours in each time slot (in hours)#
#' #
#' @return the detections split by group and time slot#
#' #
#' @keywords internal#
#' #
breakByTimeframe <- function(input, timerange, timeframe) {#
  message("M: Activating separate dBBMM calculations for each time slot.")#
#
  # Separate total timeframe of tracking into temporal windows: starting at midnight#
  timeslots <- seq(from = timerange[1], #
                   to = timerange[2],#
                   by = 3600 * timeframe) # User-defined intervals (6-h default)#
#
  # Fix daylight savings shifts#
  # timeslots[lubridate::dst(timeslots)] <- timeslots[lubridate::dst(timeslots)] - 3600#
  # HF: I have disabled the line above as it was causing issues. I believe R should be able#
  #     to handle the timezones correctly on its own. We need to keep an eye on this until#
  #     we do a test on a longer dataset, that spans over Summer and Winter time.#
  output <- lapply(input, function(x) {#
    x$Slot <- NA_integer_#
    recipient <- lapply(1:(length(timeslots) - 1), function(i) {#
      link <- with(x, Timestamp >= timeslots[i] & Timestamp < timeslots[i + 1])#
      x$Slot[link] <- i#
      return(x$Slot)#
    })#
    x$Slot <- combine(recipient)#
    return(x)#
  })#
#
  output <- lapply(output, function(x) split(x, x$Slot))#
  attributes(output)$type <- "timeslot"#
  return(output)#
} #
#
#' Clip land areas from the dbbmm output#
#' #
#' @param input The dbbmm#
#' @param base.raster the base raster#
#' #
#' @return the dbbmm rasters with the land areas cut out#
#' #
#' @keywords internal#
#' #
clipLand <- function(input, base.raster) {#
  if (attributes(input)$type == "group") {#
    dbbmm.rasters <- lapply(input, function(x) {#
      ras <- move::getVolumeUD(x)#
      water <- raster::mask(x = ras, mask = base.raster, inverse = TRUE)#
      return(water)#
      })#
    attributes(dbbmm.rasters)$type = "group"#
  }#
  if (attributes(input)$type == "timeslot") {#
    dbbmm.rasters <- lapply(input, function(group) {#
      lapply(group, function(x) {#
        ras <- move::getVolumeUD(x)#
        water <- raster::mask(x = ras, mask = base.raster, inverse = TRUE)#
        return(water)#
        })  #
      })  #
    attributes(dbbmm.rasters)$type = "timeslot"#
  }#
  return(dbbmm.rasters)#
}#
#
#' Combine a list of vectors#
#'#
#' Intended to combine vectors where, for each position, only one of the vectors contains data (i.e. the remaining are NA's).#
#' #
#' Copied from \link[actel]{actel}#
#' #
#' @param input a list of vectors with non-overlapping data.#
#' #
#' @return A single vector where all data has been combined.#
#' #
#' @keywords internal#
#' #
combine <- function(input) {#
  if (!inherits(input, "list")) #
    stop("'combine' is only intended to combine a list of vectors to a single vector.")#
  if (length(input) == 1) {#
    output <- input[[1]]#
  } else {#
    if (var(unlist(lapply(input, length))) != 0) #
      stop("All vectors to combine should have the same length.")#
    output <- input[[1]]#
    for (i in 2:length(input)) {#
      to.replace <- !is.na(input[[i]])#
      if (any(!is.na(output)[to.replace])) #
        stop("Trying to combine value to an already used position.")#
      output[to.replace] <- input[[i]][to.replace]#
    }#
  }#
  return(output)#
}#
#' compiles summary information for the tracks used in the dbbmm#
#' #
#' @param group.list the lists of valid detections#
#' #
#' @return a list of valid track summaries#
#' #
#' @keywords internal#
#' #
compileTrackInfo <- function(group.list) {  #
  if (attributes(group.list)$type == "group") {#
    recipient0 <- lapply(group.list, function(group) { # split by group#
      by.tag <- split(group, as.character(group$Transmitter))#
      recipient <- lapply(by.tag, function(tag) { # split by tag#
        aux <- split(tag, as.character(tag$Track))#
        track.aux <- lapply(aux, function(x) { # split by track#
          data.frame(Group = NA_character_,#
            Tag = x$Transmitter[1],#
            Track = x$Track[1], # compile track info#
            valid.n = nrow(x),#
            First.time = x$Timestamp[1],#
            Last.time = x$Timestamp[nrow(x)],#
            Timespan = difftime(x$Timestamp[nrow(x)], x$Timestamp[1], units = "hours")#
            )#
        })#
        tracks <- data.table::rbindlist(track.aux)#
        return(tracks)#
      }) # return by tag#
      return(recipient)#
    }) # return by group#
  }#
#
  if (attributes(group.list)$type == "timeslot") {#
    recipient0 <- lapply(group.list, function(group) { # break by group#
      recipient1 <- lapply(group, function(timeslot) { # break by timeslot#
        by.tag <- split(timeslot, as.character(timeslot$Transmitter))#
        recipient2 <- lapply(by.tag, function(tag) { # break by tag#
          aux <- split(tag, as.character(tag$Track))#
          track.aux <- lapply(aux, function(x) {  # break by track#
            data.frame(Group = NA_character_,#
              Tag = x$Transmitter[1],#
              Track = x$Track[1], # collect info#
              Slot = x$Slot[1],#
              valid.n = nrow(x),#
              First.time = x$Timestamp[1],#
              Last.time = x$Timestamp[nrow(x)],#
              Timespan = difftime(x$Timestamp[nrow(x)], x$Timestamp[1], units = "hours")#
              )#
          })#
          tracks <- data.table::rbindlist(track.aux) # bind tracks#
          return(tracks)#
        }) # return by tag#
        return(recipient2)#
      }) # return by timeslot#
      # simplify#
      aux <- unlist(recipient1, recursive = FALSE)#
      unique.tags <- sort(unique(gsub("^[^\\.]*\\.", "", names(aux))))#
      output <- lapply(unique.tags, function(i) { # merge info from the same tag#
        link <- grepl(paste0(i, "$"), names(aux))#
        data.table::rbindlist(aux[which(link)])#
      })#
      names(output) <- unique.tags#
      return(output)#
    }) # return by group#
  }#
#
  # add group info#
  aux <- lapply(names(recipient0), function(group) {#
    lapply(recipient0[[group]], function(tag) {#
      tag$Group <- group#
      return(tag)#
    })#
  })#
#
  # simplify#
  output <- data.table::rbindlist(unlist(aux, recursive = FALSE))#
  return(output)#
}#
#
#' Prepare detections for the dBBMM#
#' #
#' Joins the detections by group.#
#' #
#' @param detections a list of detections per fish#
#' @param tz the time UTM.zone of the study area#
#' #
#' @return the detections grouped by group#
#' #
#' @keywords internal#
#' #
groupDetections <- function(detections, tz, bio, timeframe = NULL) {#
  # Split transmitters per group variable#
  df.signal <- data.frame(Transmitter = names(detections),#
                          stringsAsFactors = FALSE)#
  # HF: remove spaces from groups#
  if (any(grepl(" ", bio$Group))) {#
    warning("Substituting spaces in group names to avoid function failure.", immediate. = TRUE, call. = FALSE)#
    bio$Group <- gsub(" ", "_", bio$Group)#
  }#
  df.signal$Group <- as.character(bio$Group[match(df.signal$Transmitter, bio$Transmitter)])#
#
  # Get signals per group#
  signal.list <- split(df.signal, df.signal$Group)#
  group.list <- lapply(signal.list, function(x) {#
    output <- do.call(rbind.data.frame, detections[match(x$Transmitter, names(detections))])#
    output$ID <- paste0(output$Transmitter, "_", output$Track) #
    return(output)#
  })#
  attributes(group.list)$type <- "group"#
  # Split data by time slot, if necessary#
  if (!is.null(timeframe)) {#
    aux <- range(sapply(detections, function(x) x$Timestamp))#
    aux <- as.POSIXct(aux, origin = "1970-01-01 00:00:00", tz = tz)#
    aux[1] <- round.POSIXt(x = (aux[1] - 43200), units = "days") # extract 12-h (round previous day)#
    aux[2] <- round.POSIXt(x = (aux[2] + 43200), units = "days") # add 12-h (round next day)#
    group.list <- breakByTimeframe(input = group.list, timerange = aux, timeframe = timeframe)#
  }#
#
  return(group.list)#
}#
#
#' Convert numeric time to HH:MM#
#' #
#' Copied from \link[actel]{actel}#
#'#
#' @param x Single string or a vector of strings containing hours:minutes or hours:minutes:seconds.#
#' @param format the format of x, one of "h" (hours), "m", (minutes) or "s" (seconds).#
#' @param seconds Logical; If TRUE, output is returned in HH:MM:SS format.#
#' #
#' @return Decimal hour equivalent (single value or vector)#
#' #
#' @keywords internal#
#' #
minuteTime <- function(x, format = c("h", "m", "s"), seconds = TRUE) {#
  format <- match.arg(format)#
  .converter <- function(x) {#
    if(!is.na(x)){#
      if(x < 0){#
        x <- abs(x)#
        neg = TRUE#
      } else neg = FALSE#
      if(format == "h") #
        x = x#
      if(format == "m") #
        x = x/60#
      if(format == "s") #
        x = x/3600#
      m = x %% 1#
      h = x - m#
      m = 60 * m#
      s = m %% 1#
      m = m - s#
      s = round(60 * s, 0)#
      if (h < 10) h <- paste0(0, h)#
      if (!seconds & s>30) m = m + 1#
      if (m < 10) m <- paste0(0, m)#
      if (s < 10) s <- paste0(0, s)#
      if (seconds) #
        x <- paste(h, m, s, sep = ":")#
      else #
        x <- paste(h, m, sep = ":")#
      if (neg) x <- paste("-", x)#
    }#
    return(x)#
  }#
  if (length(x) < 1) stop("Input appears to be empty.")#
  if (!is.numeric(x)) stop("Input is not numeric.")#
  if (length(x) == 1) output <- .converter(x)#
  if (length(x) > 1) output <- unlist(lapply(x, .converter))#
  return(output)#
}#
#
#' Converts coordinates to UTM projection#
#' #
#' Convert Coordinate Reference System (CRS) from lonlat to #
#' metric UTM projection, as required for calculating the dynamic Brownian Bridge #
#' Movement Model. #
#'#
#' @param input The detections data frame#
#' @param UTM the UTM zone chosen by the user#
#' @param crs The original coordinate system#
#' #
#' @return Dataframe with the converted coordinates in UTM.#
#' #
#' @keywords internal#
#' #
toUTM <- function(input, UTM, crs) {#
  input$O.LAT <- input$Latitude#
  input$O.LON <- input$Longitude#
  xy <- data.frame(ID = 1:nrow(input), X = input$Longitude, Y = input$Latitude)#
  sp::coordinates(xy) <- c("X", "Y")#
  sp::proj4string(xy) <- sp::CRS(as.character(crs))#
  metric.coords <- as.data.frame(sp::spTransform(xy, #
    sp::CRS(paste0("+proj=utm +zone=", UTM, " +datum=WGS84 +units=m +no_defs"))))#
#
  input$Longitude <- metric.coords[, 2]#
  input$Latitude <- metric.coords[, 3]#
  return(input)#
}#
#
#' Select specific transmitters to analyze#
#' #
#' If the user specifies transmitters, return only the detections for those tags.#
#' #
#' @param detections The detections data frame, provided by one of the main actel functions (explore, migrate, residency)#
#' @param tags A list of transmitters to be analysed.#
#' #
#' @return the trimmed detections list#
#' #
#' @keywords internal#
#' #
trimDetections <- function(detections, tags = NULL) {#
  if (!is.null(tags)) {#
    if (any(link <- is.na(match(tags, names(detections))))) {#
      stop("tags", paste(tags[link], collapse = ", "), "are not part of the input data.", call. = FALSE)#
    }#
    detections <- detections[tags]#
  } else {#
    message("M: No specific transmitters selected. All the data will be used for analysis.")#
  }#
  return(detections)#
}
#' Total dynamic Brownian Bridge Movement Model#
#' #
#' Calculates dynamic Brownian Bridge Movement Model (dBBMM) for each track and transmitter. Tracks shorter than 30 minutes#
#' are automatically identified and not included in the analysis.#
#'#
#' @param input The output of runRSP.#
#' @param base.raster The water raster of the study area. For example the output of \code{\link[actel]{loadShape}}.#
#' @param tags Vector of transmitters to be analysed. By default all transmitters from runRSP will be analysed.#
#' @param start.time Sets the start point for analysis (format = "Y-m-d H:M:S").#
#' @param stop.time Sets the stop point for analysis (format = "Y-m-d H:M:S").#
#' @param UTM The UTM zone of the study area. Only relevant if a latlon-to-metric conversion is required.#
#' @param timeframe Temporal window size for fine-scale dBBMM in hours. If left NULL, a single dBBMM is calculated for the whole period.#
#' @param window.size The size of the moving window along the track. Larger windows provide more stable/accurate estimates of the #
#' brownian motion variance but are less well able to capture more frequent changes in behavior. This number has to be odd.#
#' @param margin The margin used for the behavioral change point analysis. This number has to be odd.#
#' @param verbose Logical: If TRUE, detailed check messages are displayed. Otherwise, only a summary is displayed.#
#' @param debug Logical: If TRUE, the function progress is saved to an RData file.#
#' #
#' @return List of calculated dBBMMs and metadata on each track used for the modelling. #
#' #
#' @examples #
#' \donttest{#
#' # Import river shapefile#
#' water <- actel::loadShape(path = system.file(package = "RSP"), #
#'  shape = "River_latlon.shp", size = 0.0001, buffer = 0.05) #
#' #
#' # Create a transition layer with 8 directions#
#' tl <- actel::transitionLayer(x = water, directions = 8)#
#' #
#' # Import example output from actel::explore() #
#' data(input.example) #
#' #
#' # Run RSP analysis#
#' rsp.data <- runRSP(input = input.example, t.layer = tl, coord.x = "Longitude", coord.y = "Latitude")#
#' #
#' # Run dynamic Brownian Bridge Movement Model (dBBMM)#
#' dbbmm.data <- dynBBMM(input = rsp.data, base.raster = water, UTM = 56)#
#' }#
#' #
#' @export#
#' #
dynBBMM <- function(input, base.raster, tags = NULL, start.time, stop.time, timeframe = NULL, UTM, #
  debug = FALSE, verbose = TRUE, window.size = 7, margin = 3) {#
  Timestamp <- NULL#
  if ((window.size %% 2) == 0) {#
    stop("'window.size' must be an odd number", call. = FALSE)#
  }#
  if ((margin %% 2) == 0) {#
    stop("'margin' must be an odd number", call. = FALSE)#
  }#
  if (debug) {#
    on.exit(save(list = ls(), file = "dynBBMM_debug.RData"), add = TRUE)#
    message("!!!--- Debug mode has been activated ---!!!")#
  }#
#
  # paint land rather than water#
  base.raster[is.na(base.raster)] <- 2#
  base.raster[base.raster == 1] <- NA#
  base.raster[base.raster == 2] <- 1#
#
  original.base.raster <- base.raster#
#
  # check input quality#
  if (!is.null(timeframe) && !is.numeric(timeframe))#
    stop("'timeframe' must be either NULL or numeric", call. = FALSE)#
  if (!is.null(timeframe) && timeframe <= 0.5)#
    stop("'timeframe' must be larger than 0.5.", call. = FALSE)#
  if (!missing(start.time) && !grepl("^[1-2][0-9][0-9][0-9]-[0-1][0-9]-[0-3][0-9] [0-2][0-9]:[0-5][0-9]:[0-5][0-9]", start.time))#
      stop("'start.time' must be in 'yyyy-mm-dd hh:mm:ss' format.\n", call. = FALSE)#
  if (!missing(stop.time) && !grepl("^[1-2][0-9][0-9][0-9]-[0-1][0-9]-[0-3][0-9] [0-2][0-9]:[0-5][0-9]:[0-5][0-9]", stop.time))#
      stop("'stop.time' must be in 'yyyy-mm-dd hh:mm:ss' format.\n", call. = FALSE)#
  # Unpack study data#
  detections <- input$detections  #
  spatial <- input$spatial#
  tz <- input$tz#
  crs <- input$crs#
  bio <- input$bio#
#
  if (as.character(crs) != as.character(raster::crs(base.raster))) # HF: This should never happen (unless the user screwed up), but I am leaving it here as a tester#
    stop("The base raster and the input data are not in the came coordinate system!", call. = FALSE)#
#
  if (raster::isLonLat(base.raster)) {#
    if (missing(UTM))#
      stop("The data are in a latitude-longitude coordinate system, which is incompatible with the dynamic brownian bridge model.\nPlease supply a 'UTM' zone for coordinate conversion.", call. = FALSE)#
    if (length(UTM) > 1)#
      stop("Please supply only one UTM zone")#
    message("M: Converting coordinates to UTM. Original latitude/longitude values for the detections will be stored in columns 'O.LAT' and 'O.LON'.")#
    flush.console()#
    detections <- lapply(detections, function(x) toUTM(x, crs = crs, UTM = UTM))#
    suppressWarnings(raster::crs(base.raster) <- "+proj=longlat +datum=WGS84 +ellps=WGS84 +towgs84=0,0,0")#
    base.raster <- suppressWarnings(raster::projectRaster(base.raster, crs = raster::crs(paste0("+proj=utm +zone=", UTM, " +datum=WGS84 +units=m +no_defs")))) #
    crs <- raster::crs(paste0("+proj=utm +zone=", UTM, " +datum=WGS84 +units=m +no_defs"))#
  } else {#
    if (!missing(UTM))#
      warning("'UTM' supplied but data is already in a metric coordinate system. Skipping transformation.", call. = FALSE, immediate. = TRUE)#
  }#
#
  # Sub-setting the data for time period of interest:#
  if (!missing(start.time) & missing(stop.time))#
    message("M: Discarding detection data previous to ",start.time," per user command.")#
#
  if (missing(start.time) & !missing(stop.time))#
    message("M: Discarding detection data posterior to ",stop.time," per user command.")#
#
  if (!missing(start.time) & !missing(stop.time)) {#
    if (stop.time < start.time)#
      stop("'stop.time' must be after 'start.time'.", call. = FALSE)#
    if (stop.time == start.time)#
      stop("'stop.time' and 'stop.time' are equal. Continuing would erase all detection data", call. = FALSE)#
      message(paste0("M: Discarding detection data previous to ",start.time," and posterior to ",stop.time," per user command."))#
  }#
#
  if (!missing(start.time)) {#
      start.time <- as.POSIXct(start.time, tz = input$tz)#
      # Detection data#
      detections <- lapply(detections, function(x){#
        x <- subset(x, Timestamp >= start.time)#
        return(x)#
      })#
      remove.empty <- sapply(detections, nrow) != 0#
      detections <- detections[remove.empty]#
    }#
    if (!missing(stop.time)) {#
      stop.time <- as.POSIXct(stop.time, tz = input$tz)#
      # Detection data#
      detections <- lapply(detections, function(x){#
        x <- subset(x, Timestamp <= stop.time)#
        return(x)#
      })#
      remove.empty <- sapply(detections, nrow) != 0#
      detections <- detections[remove.empty]#
    }#
  # Prepare detections#
  message("M: Preparing data to apply dBBMM.")#
  detections <- trimDetections(detections = detections, tags = tags)#
  group.list <- groupDetections(detections = detections, tz = tz, bio = bio, timeframe = timeframe) #
#
  if (attributes(group.list)$type == "group")#
    before <- sum(unlist(lapply(group.list, nrow)))#
  if (attributes(group.list)$type == "timeslot")#
    before <- sum(unlist(lapply(group.list, function(group) lapply(group, nrow))))#
#
  group.list <- checkGroupQuality(input = group.list, verbose = verbose)#
#
  if (attributes(group.list)$type == "group")#
    after <- sum(unlist(lapply(group.list, nrow)))#
  if (attributes(group.list)$type == "timeslot")#
    after <- sum(unlist(lapply(group.list, function(group) lapply(group, nrow))))#
#
  if (before != after)#
    message("M: In total, ", before - after, " detections were excluded as they failed the track quality checks.")#
  rm(before, after)#
#
  valid.tracks <- compileTrackInfo(group.list = group.list)#
#
  # Calculate dBBMM#
  mod_dbbmm <- calculateDBBMM(input = group.list, crs = crs, base.raster = base.raster, #
    window.size = window.size, margin = margin)#
#
  # Remove land areas#
  message("M: Subtracting land areas from output.")#
  dbbmm.rasters <- clipLand(input = mod_dbbmm, base.raster)#
  if (attributes(mod_dbbmm)$type == "group")#
    return(list(dbbmm = mod_dbbmm, base.raster = original.base.raster, valid.tracks = valid.tracks,#
      group.rasters = dbbmm.rasters, spatial = spatial))  #
#
  if (attributes(mod_dbbmm)$type == "timeslot"){#
    # make timeslot data frame before finishing#
    aux <- do.call(rbind.data.frame, detections)#
    aux <- range(aux$Timestamp)#
    aux[1] <- round.POSIXt(x = (aux[1]), units = "days") #
    aux[2] <- round.POSIXt(x = (aux[2]), units = "days")#
    timebreaks <- seq(from = aux[1], #
                     to = aux[2],#
                     by = 3600 * timeframe)#
#
    timeslots <- data.frame(#
      slot = 1:(length(timebreaks) - 1),#
      start = timebreaks[-length(timebreaks)],#
      stop = timebreaks[-1] - 1)#
    return(list(dbbmm = mod_dbbmm, base.raster = original.base.raster, valid.tracks = valid.tracks,#
      group.rasters = dbbmm.rasters, timeslots = timeslots, spatial = spatial)) #
  }#
}#
#
#' Calculate the dBBMM for each group#
#' #
#' @param input The detections to be used as input for the model#
#' @inheritParams groupDetections#
#' @param window.size The window size#
#' @param margin The margin#
#' @param base.raster The raster object#
#' #
#' @return A list of dBBMM's per group#
#' #
#' @keywords internal#
#' #
calculateDBBMM <- function(input, crs, base.raster, window.size, margin) {#
#
  the.dbbmm.call <- function(x, rst, err, window.size, margin) {#
    output <- move::brownian.bridge.dyn(#
      object = x,#
      raster = rst,  #
      window.size = window.size,#
      margin = margin,#
      location.error = err)#
    return(output)#
  }#
#
  if (attributes(input)$type == "group") {#
    # Create a move object for all animals together:#
    loc <- lapply(input, function(i) {#
      move::move(x = i$Longitude, y = i$Latitude, time = i$Timestamp,#
                 proj = crs, #
                 animal = i$ID)#
    })#
#
    # Calculate dynamic Brownian Bridge Movement Model:#
    mod_dbbmm <- lapply(seq_along(loc), function(i) {#
      message("M: Calculating dBBMM: ", crayon::bold(crayon::green(names(loc)[i])))#
      flush.console()#
      time.spent <- system.time(suppressWarnings(suppressMessages( # HF: temporarily suppress new raster warnings. We need to revisit this once move::brownian.bridge.dyn has been updated#
        output <- tryCatch(#
          callr::r(func = the.dbbmm.call, #
                   args = list(x = loc[[i]], #
                               rst = base.raster, #
                               window.size = window.size,#
                               margin = margin,#
                               err = input[[i]]$Error),#
                   spinner = TRUE),#
          error = function(e) {#
            if (grepl("consider extending the raster", e))#
              stop("The brownian bridge model needs a larger raster to work on. This could happen because some of the detections are too close to the raster's edge. #
You can create a larger raster by using the argument 'buffer' in loadShape. If the error persists, increase the buffer size further.", call. = FALSE)#
            else#
              stop(e)#
          })#
        )))#
      if (length(unique(input[[i]]$ID)) == 1)#
        names(output) <- unique(input[[i]]$ID)#
#
      time.spent <- minuteTime(time.spent["elapsed"], format = "s", seconds = TRUE)#
      message("M: Success! (Time spent: ", time.spent, ")")#
      flush.console()#
      return(output)#
      })#
    names(mod_dbbmm) <- names(loc)#
    attributes(mod_dbbmm)$type <- "group"#
    return(mod_dbbmm)#
  }#
#
  if (attributes(input)$type == "timeslot") {#
    # Create a move object for per timeslot:#
    loc <- lapply(input, function(group) {#
      aux <- lapply(group, function(timeslot) {#
        move::move(x = timeslot$Longitude, y = timeslot$Latitude, time = timeslot$Timestamp,#
                   proj = crs, #
                   animal = timeslot$ID)#
      })#
    })#
#
    # Calculate dynamic Brownian Bridge Movement Model:#
    mod_dbbmm <- lapply(seq_along(loc), function(g) {#
      message("M: Calculating dBBMM: ", crayon::bold(crayon::green(names(loc)[g])))#
      flush.console()#
      pb <-  txtProgressBar(min = 0, max = length(loc[[g]]),  #
                            initial = 0, style = 3, width = 60)#
      counter <- 0#
      time.spent <- system.time(suppressWarnings(suppressMessages( # HF: temporarily suppress new raster warnings. We need to revisit this once move::brownian.bridge.dyn has been updated#
        aux <- lapply(seq_along(loc[[g]]), function(i) {#
          output <- tryCatch(#
            callr::r(func = the.dbbmm.call, #
                     args = list(x = loc[[g]][[i]], #
                                 rst = base.raster, #
                                 window.size = window.size,#
                                 margin = margin,#
                                 err = input[[g]][[i]]$Error),                              #
                     spinner = TRUE),#
            error = function(e) {#
              if (grepl("consider extending the raster", e))#
                stop("The brownian bridge model needs a larger raster to work on. This could happen because some of the detections are too close to the raster's edge. #
You can create a larger raster by using the argument 'buffer' in loadShape. If the error persists, increase the buffer size further.", call. = FALSE)#
              else#
                stop(e)#
            })#
            if(length(names(output)) == 1)#
              names(output) <- unique(input[[g]][[i]]$ID)#
            counter <<- counter + 1#
            setTxtProgressBar(pb, counter) # Progress bar    #
          return(output)#
        })#
      )))#
      close(pb)#
      message("M: Success! (Time spent: ", minuteTime(time.spent["elapsed"], format = "s", seconds = TRUE), ")")#
      flush.console()#
      names(aux) <- names(loc[[g]])#
      return(aux)#
      })#
    names(mod_dbbmm) <- names(loc)#
    attributes(mod_dbbmm)$type <- "timeslot"#
    return(mod_dbbmm)#
  }#
}
#' Calculate water areas per group or track#
#'#
#' @param input The output of \code{\link{dynBBMM}}#
#' @param breaks The contours for calculating usage areas in squared metres. By default the 95\% and 50\% contours are used. #
#' @param type one of "group" or "track". If set to "track", UD rasters for each track are also supplied.#
#' #
#' @return A list of areas per track, per group#
#' #
#' @examples #
#' \donttest{#
#' # Import river shapefile#
#' water <- actel::loadShape(path = system.file(package = "RSP"), #
#'  shape = "River_latlon.shp", size = 0.0001, buffer = 0.05) #
#' #
#' # Create a transition layer with 8 directions#
#' tl <- actel::transitionLayer(x = water, directions = 8)#
#' #
#' # Import example output from actel::explore() #
#' data(input.example) #
#' #
#' # Run RSP analysis#
#' rsp.data <- runRSP(input = input.example, t.layer = tl, coord.x = "Longitude", coord.y = "Latitude")#
#' #
#' # Run dynamic Brownian Bridge Movement Model (dBBMM)#
#' dbbmm.data <- dynBBMM(input = rsp.data, base.raster = water, UTM = 56)#
#' #
#' # Get dBBMM areas at group level#
#' areas.group <- getAreas(dbbmm.data, type = "group", breaks = c(0.5, 0.95))#
#' }#
#' #
#' @export#
#' #
getAreas <- function(input, type = c("group", "track"), breaks = c(0.5, 0.95)) {#
#
  type <- match.arg(type)#
  dbbmm.rasters <- input$group.rasters#
#
  if (any(breaks >= 1) | any(breaks <= 0))#
    stop("breaks must be between 0 and 1 (both exclusive).", call. = FALSE)#
  if (attributes(dbbmm.rasters)$type == "group") {#
    # Clip dBBMM contours by land limits#
    water.areas <- lapply(dbbmm.rasters, function(the.dbbmm) {#
      if (type == "track") {#
        output_i <- lapply(names(the.dbbmm), function(i){#
          # Calculate contour areas#
          output_breaks <- lapply(breaks, function(limit) {#
            aux <- the.dbbmm[[i]] <= limit#
            output <- sum(raster::values(aux), na.rm = TRUE) * raster::xres(aux) * raster::yres(aux)#
            return(list(raster = aux, area = output))#
          })#
          names(output_breaks) <- breaks#
          return(output_breaks) #
        })#
        names(output_i) <- names(the.dbbmm)#
        return(output_i)#
      }#
      if (type == "group") {#
        output_breaks <- lapply(breaks, function(limit) {#
          aux <- the.dbbmm <= limit#
          output <- sum(raster::values(aux), na.rm = TRUE) * raster::xres(aux) * raster::yres(aux)#
          return(list(raster = aux, area = output))#
        })#
        names(output_breaks) <- breaks#
        return(output_breaks) #
      }#
    })#
    names(water.areas) <- names(dbbmm.rasters)#
#
    # simplify the output#
    # make summary tables per group#
    tracks.list <- lapply(water.areas, function(group) {#
      if (type == "track") {#
        aux <- lapply(group, function(track) {#
          aux <- sapply(breaks, function(i) track[[as.character(i)]]$area)#
          names(aux) <- breaks#
          return(aux)#
        })#
        recipient <- do.call(rbind.data.frame, lapply(aux, unlist))#
        colnames(recipient) <- paste0("area", gsub("^0", "", breaks))#
        recipient$ID <- names(group)#
        rownames(recipient) <- 1:nrow(recipient)#
        return(recipient[, c(length(breaks) + 1, 1:length(breaks))])#
      }#
      if (type == "group") {#
        aux <- sapply(breaks, function(i) group[[as.character(i)]]$area)#
        names(aux) <- breaks#
        return(aux)#
      }#
    })#
    if (type == "track") {#
      names(tracks.list) <- names(water.areas)#
    }#
    if (type == "group") {#
      recipient <- do.call(rbind.data.frame, lapply(tracks.list, unlist))#
      colnames(recipient) <- paste0("area", gsub("^0", "", breaks))#
      recipient$ID <- names(water.areas)#
      rownames(recipient) <- 1:nrow(recipient)#
      tracks.list <- recipient[, c(length(breaks) + 1, 1:length(breaks))]#
    }#
#
    # For track areas, grab the rasters only in a separate object#
    if (type == "track") {#
      track.rasters <- lapply(water.areas, function(group) {#
        lapply(group, function(track) {#
          aux <- lapply(breaks, function(i) track[[as.character(i)]]$raster)#
          names(aux) <- breaks#
          return(aux)#
        })#
      })#
    }#
    if (type == "group") {#
      track.rasters <- lapply(water.areas, function(group) {#
        aux <- lapply(breaks, function(i) {#
          output <- group[[as.character(i)]]$raster # extract relevant raster#
          if (class(output) != "RasterLayer") # flatten it if needed#
            return(raster::calc(output, fun = max, na.rm = TRUE))#
          else#
            return(output)         #
        })#
        names(aux) <- breaks#
        return(aux)#
      })#
    }#
  }#
#
  if (attributes(dbbmm.rasters)$type == "timeslot") {#
    # Clip dBBMM contours by land limits#
    if (type == "track")#
      pb.end <- sum(unlist(lapply(dbbmm.rasters, function(x) lapply(x, function(xi) length(names(xi))))))#
    if (type == "group")#
      pb.end <- sum(unlist(lapply(dbbmm.rasters, function(x) length(names(x)))))#
#
    pb <-  txtProgressBar(min = 0, max = pb.end,  #
                          initial = 0, style = 3, width = 60)#
    counter <- 0 #
    water.areas <- lapply(dbbmm.rasters, function(group) {#
      output <- lapply(group, function(timeslot) {#
        if (type == "track") {#
          output_i <- lapply(names(timeslot), function(i){#
            # Calculate contour areas#
            output_breaks <- lapply(breaks, function(limit) {#
              aux <- timeslot[[i]] <= limit#
              output <- sum(raster::values(aux), na.rm = TRUE) * raster::xres(aux) * raster::yres(aux)#
              return(list(raster = aux, area = output))#
            })#
            counter <<- counter + 1#
            setTxtProgressBar(pb, counter) # Progress bar    #
            names(output_breaks) <- breaks#
            return(output_breaks) #
          })#
          counter <<- counter#
          names(output_i) <- names(timeslot)#
          return(output_i)#
        }#
        if (type == "group") {#
          output_breaks <- lapply(breaks, function(limit) {#
            aux <- timeslot <= limit#
            output <- sum(raster::values(aux), na.rm = TRUE) * raster::xres(aux) * raster::yres(aux)#
            return(list(raster = aux, area = output))#
          })#
          counter <<- counter + 1#
          setTxtProgressBar(pb, counter) # Progress bar    #
          names(output_breaks) <- breaks#
          return(output_breaks) #
        }#
      })#
      counter <<- counter#
      names(output) <- names(group)#
      return(output)#
    })#
    names(water.areas) <- names(dbbmm.rasters)#
    close(pb)#
    # simplify the output  #
    tracks.list <- lapply(water.areas, function(group) { # for each group,#
      aux <- lapply(names(group), function(ts) { # for each timeslot,#
        timeslot <- group[[ts]]#
        if (type == "track") {#
          aux <- lapply(timeslot, function(track) { # for each track,#
            aux <- sapply(breaks, function(i) track[[as.character(i)]]$area) # for each break, collect the area#
            names(aux) <- breaks # name columns with the break names#
            return(aux)#
          })#
          recipient <- do.call(rbind.data.frame, lapply(aux, unlist)) # combine rows into dataframe#
          rownames(recipient) <- names(timeslot) # each row is a timeslot? hm...#
        }#
        if (type == "group") {#
          aux <- sapply(breaks, function(i) timeslot[[as.character(i)]]$area)#
          recipient <- t(as.data.frame(aux))#
          rownames(recipient) <- ts#
        }#
        colnames(recipient) <- paste0("area", gsub("^0", "", breaks))      #
        return(as.data.frame(recipient))#
      })#
      names(aux) <- names(group)#
      aux <- lapply(seq_along(aux), function(i) {#
        if (type == "track") {#
          aux[[i]]$ID <- rownames(aux[[i]])#
          aux[[i]]$Slot <- names(aux)[i]#
        }#
        if (type == "group")#
          aux[[i]]$Slot <- rownames(aux[[i]])#
        return(aux[[i]])#
      })#
      aux <- do.call(rbind.data.frame, aux)#
      rownames(aux) <- 1:nrow(aux)#
      if (type == "track")#
        return(aux[, c(length(breaks) + 2, length(breaks) + 1, 1:length(breaks))])#
      if (type == "group")#
        return(aux[, c(length(breaks) + 1, 1:length(breaks))])#
    })#
    # grab the rasters only in a separate object#
    if (type == "track") {#
      track.rasters <- lapply(water.areas, function(group) {#
        lapply(group, function(timeslot) {#
          lapply(timeslot, function(track) {#
            aux <- lapply(breaks, function(i) track[[as.character(i)]]$raster)#
            names(aux) <- breaks#
            return(aux)#
          })#
        })#
      })#
    }#
    if (type == "group") {#
      track.rasters <- lapply(water.areas, function(group) {#
        lapply(group, function(timeslot) {#
          aux <- lapply(breaks, function(i) {#
            output <- timeslot[[as.character(i)]]$raster # extract relevant raster#
            if (class(output) != "RasterLayer") # flatten it if needed#
              return(raster::calc(output, fun = max, na.rm = TRUE))#
            else#
              return(output)         #
          })#
          names(aux) <- breaks#
          return(aux)#
        })#
      })#
    }#
  }#
  output <- list(areas = tracks.list, rasters = track.rasters)#
  attributes(output)$type <- attributes(dbbmm.rasters)$type#
  attributes(output)$area <- type#
  attributes(output)$breaks <- breaks#
  return(output)#
}#
#' Get centroid locations of dBBMM#
#' #
#' When a timeslot dBBMM analysis is conducted, this function can be used to obtain #
#' centroid latitude and longitude locations between all utilization distribution#
#' contours at group or track level. #
#'#
#' @param input The output of \code{\link{dynBBMM}}.#
#' @param areas The output of \code{\link{getAreas}}.#
#' @param type Character vector specifying the type of getAreas analysis performed: "group" or "track".#
#' @param level Numeric vector defining the contour level of dBBMM of interest to extract the centroid positions. #
#' @param group Character vector defining the group of interest for the analysis, when getAreas is of type "group".#
#' @param UTM Numeric vector representing the UTM zone of the study area. #
#'#
#' @return A dataframe containing the centroid positions per each timeslot#
#' #
#' @examples #
#' \donttest{#
#' # Import river shapefile#
#' water <- actel::loadShape(path = system.file(package = "RSP"), #
#'  shape = "River_latlon.shp", size = 0.0001, buffer = 0.05) #
#' #
#' # Create a transition layer with 8 directions#
#' tl <- actel::transitionLayer(x = water, directions = 8)#
#' #
#' # Import example output from actel::explore() #
#' data(input.example) #
#' #
#' # Run RSP analysis#
#' rsp.data <- runRSP(input = input.example, t.layer = tl, coord.x = "Longitude", coord.y = "Latitude")#
#' #
#' # Run dynamic Brownian Bridge Movement Model (dBBMM) with timeslots:#
#' dbbmm.data <- dynBBMM(input = rsp.data, base.raster = water, UTM = 56, timeframe = 2)#
#' #
#' # Get dBBMM areas at group level#
#' areas.group <- getAreas(dbbmm.data, type = "group", breaks = c(0.5, 0.95))#
#' #
#' # Obtaing centroid coordinate locations of dBBMM:#
#' df.centroid <- getCentroids(input = dbbmm.data, areas = areas.group, type = "group",#
#'    level = 0.95, group = "G1", UTM = 56)#
#' }#
#' #
#' @export#
#' #
getCentroids <- function(input, areas, type, level, group, UTM) {#
  if (type == "group") {#
    if (length(which(colnames(areas$areas[[1]]) == paste0("area.", stringr::str_remove(level, pattern = "0.")))) == 0)      #
      stop("The level specified was not found in the input object.", call. = FALSE)#
    if (length(which(names(areas$areas) == group)) == 0)#
      stop("The group specified was not found in the areas object.", call. = FALSE)#
    slots <- input$timeslots$slot#
    aux.areas <- areas$areas[[which(names(areas$areas) == group)]]#
    aux.rasters <- areas$rasters[[which(names(areas$areas) == group)]]#
    slots.aux <- aux.areas$Slot#
    lat.save <- NULL#
    lon.save <- NULL#
    suppressWarnings(for (i in 1:length(slots.aux)) {#
      aux <- aux.rasters[[which(names(aux.rasters) == slots.aux[i])]]#
      aux <- aux[[which(names(aux) == as.character(level))]]#
      aux1 <- colMeans(raster::xyFromCell(aux, which(aux[] == 1)))#
      xy <- data.frame(X = aux1[1], Y = aux1[2])#
      sp::coordinates(xy) <- c("X", "Y")#
      sp::proj4string(xy) <- sp::CRS(paste0("+proj=utm +zone=", UTM, "+datum=WGS84 +units=m +no_defs +ellps=WGS84 +towgs84=0,0,0"))#
      trans.xy <- sp::spTransform(xy, sp::CRS("+proj=longlat +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +no_defs"))#
      lat.save <- c(lat.save, raster::extent(trans.xy)[3])#
      lon.save <- c(lon.save, raster::extent(trans.xy)[1])#
    })#
    aux.centroid <- data.frame(slots = slots.aux, lat = lat.save, lon = lon.save)#
    df.centroid <- input$timeslots#
    df.centroid$Group <- group#
    df.centroid$Level <- paste0(level * 100, "%")#
    df.centroid$Centroid.lat <- aux.centroid$lat[match(df.centroid$slot, aux.centroid$slots)]#
    df.centroid$Centroid.lon <- aux.centroid$lon[match(df.centroid$slot, aux.centroid$slots)]#
    return(df.centroid)        #
  }#
#
  if (type == "track") {#
    if (length(which(colnames(areas$areas[[1]]) == paste0("area.", stringr::str_remove(level, pattern = "0.")))) == 0)      #
      stop("The level specified was not found in the input object.", call. = FALSE)#
    groups <- names(areas$areas)#
    slots <- input$timeslots$slot#
    groups.save <- NULL#
    track.save <- NULL#
    slots.save <- NULL#
    lat.save <- NULL#
    lon.save <- NULL  #
    for (i in 1:length(groups)) {#
      aux.areas <- areas$areas[[which(names(areas$areas) == groups[i])]]#
      aux.rasters <- areas$rasters[[which(names(areas$areas) == groups[i])]]#
      slots.aux <- unique(aux.areas$Slot)#
      for (ii in 1:length(slots.aux)) {#
        aux <- aux.rasters[[which(names(aux.rasters) == slots.aux[ii])]]#
        suppressWarnings(for (iii in 1:length(names(aux))) {#
          slots.save <- c(slots.save, slots.aux[ii])#
          groups.save <- c(groups.save, groups[i])#
          track.save <- c(track.save, names(aux)[iii])#
          aux.file <- aux[[iii]][[which(names(aux[[iii]]) == as.character(level))]]#
          aux1 <- colMeans(raster::xyFromCell(aux.file, which(aux.file[] == 1)))#
          xy <- data.frame(X = aux1[1], Y = aux1[2])#
          sp::coordinates(xy) <- c("X", "Y")#
          sp::proj4string(xy) <- sp::CRS(paste0("+proj=utm +zone=", UTM, "+datum=WGS84 +units=m +no_defs +ellps=WGS84 +towgs84=0,0,0"))#
          trans.xy <- sp::spTransform(xy, sp::CRS("+proj=longlat +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +no_defs"))#
          lat.save <- c(lat.save, raster::extent(trans.xy)[3])#
          lon.save <- c(lon.save, raster::extent(trans.xy)[1])#
        })#
      }#
    }#
    aux.centroid <- data.frame(Group = groups.save, Track = track.save, slot = slots.save,#
      Centroid.lat = lat.save, Centroid.lon = lon.save, Level = paste0(level * 100, "%"))#
    aux.centroid$start <- input$timeslots$start[match(aux.centroid$slot, input$timeslots$slot)]#
    aux.centroid$stop <- input$timeslots$stop[match(aux.centroid$slot, input$timeslots$slot)]#
    aux.centroid <- aux.centroid[, c(3, 7, 8, 1, 2, 6, 4, 5)]#
    return(aux.centroid)  #
  }#
}#
#' Get total distances travelled #
#' #
#' Obtain the total distances travelled (in kilometres) for the tracked animals, using only the #
#' receiver locations and also adding the RSP positions. #
#'#
#' @param input RSP dataset as returned by RSP.#
#' #
#' @return A dataframe containing the total distances travelled during each RSP track.  #
#' #
#' @examples #
#' \donttest{#
#' # Import river shapefile#
#' water <- actel::loadShape(path = system.file(package = "RSP"), #
#'  shape = "River_latlon.shp", size = 0.0001, buffer = 0.05) #
#' #
#' # Create a transition layer with 8 directions#
#' tl <- actel::transitionLayer(x = water, directions = 8)#
#' #
#' # Import example output from actel::explore() #
#' data(input.example) #
#' #
#' # Run RSP analysis#
#' rsp.data <- runRSP(input = input.example, t.layer = tl, coord.x = "Longitude", coord.y = "Latitude")#
#' #
#' # Calculate distances travelled#
#' distance.data <- getDistances(rsp.data)#
#' }#
#' #
#' @export#
#' #
getDistances <- function(input) {#
  detections <- input$detections#
#
  df.diag <- lapply(seq_along(detections), function(i) {#
    df.aux <- split(detections[[i]], detections[[i]]$Track)#
    track <- names(df.aux) # Analyse tracks individually#
    aux <- lapply(seq_along(df.aux), function(j) {#
      df.rec <- subset(df.aux[[j]], Position == "Receiver")#
#
      # Receiver distances only#
      receiver.from.coords <- sp::SpatialPoints(data.frame(#
        x = df.rec$Longitude[-nrow(df.rec)],#
        y = df.rec$Latitude[-nrow(df.rec)]))#
      raster::crs(receiver.from.coords) <- input$crs#
      receiver.from.coords.wgs84 <- as.data.frame(sp::spTransform(receiver.from.coords, "+init=epsg:4326"))#
#
      receiver.to.coords  <- sp::SpatialPoints(data.frame(#
        x = df.rec$Longitude[-1],#
        y = df.rec$Latitude[-1]))#
      raster::crs(receiver.to.coords) <- input$crs#
      receiver.to.coords.wgs84 <- as.data.frame(sp::spTransform(receiver.to.coords, "+init=epsg:4326"))#
#
      receiver.combined.coords.wgs84 <- cbind(#
        receiver.from.coords.wgs84,#
        receiver.to.coords.wgs84)#
      receiver.distances <- apply(receiver.combined.coords.wgs84, 1, #
        function(r) geosphere::distm(x = c(r[1], r[2]), y = c(r[3], r[4])))#
#
      receiver.total.distance <- sum(receiver.distances)#
      # Receiver + RSP distances#
      combined.from.coords <- sp::SpatialPoints(data.frame(#
        x = df.aux[[j]]$Longitude[-nrow(df.aux[[j]])],#
        y = df.aux[[j]]$Latitude[-nrow(df.aux[[j]])]))#
      raster::crs(combined.from.coords) <- input$crs#
      combined.from.coords.wgs84 <- as.data.frame(sp::spTransform(combined.from.coords, "+init=epsg:4326"))#
#
      combined.to.coords  <- sp::SpatialPoints(data.frame(#
        x = df.aux[[j]]$Longitude[-1],#
        y = df.aux[[j]]$Latitude[-1]))#
      raster::crs(combined.to.coords) <- input$crs#
      combined.to.coords.wgs84 <- as.data.frame(sp::spTransform(combined.to.coords, "+init=epsg:4326"))#
#
      combined.combined.coords.wgs84 <- cbind(#
        combined.from.coords.wgs84,#
        combined.to.coords.wgs84)#
      combined.distances <- apply(combined.combined.coords.wgs84, 1, #
        function(r) geosphere::distm(x = c(r[1], r[2]), y = c(r[3], r[4])))#
#
      combined.total.distance <- sum(combined.distances)#
      # Save output:#
      recipient <- data.frame(#
        Animal.tracked = rep(names(detections)[i], 2),#
        Track = rep(names(df.aux)[j], 2),#
        Day.n = rep(length(unique(df.aux[[j]]$Date)), 2),#
        Loc.type = c("Receiver", "RSP"),#
        Dist.travel = c(receiver.total.distance, combined.total.distance)#
        )#
#
      return(recipient)#
    })#
    return(as.data.frame(data.table::rbindlist(aux)))#
  })#
  output <- as.data.frame(data.table::rbindlist(df.diag))#
#
  # Add corresponding groups:#
  bio.aux <- data.frame(Group = input$bio$Group, Transmitter = input$bio$Transmitter)#
  bio.aux <- bio.aux[complete.cases(bio.aux), ]#
  bio.aux$Group <- as.character(bio.aux$Group)#
  bio.aux$Transmitter <- as.character(bio.aux$Transmitter)#
  output$Group <- NA#
  for (i in 1:nrow(output)) {#
    output$Group[i] <- as.character(bio.aux$Group[bio.aux$Transmitter == output$Animal.tracked[i]] )#
  }#
  output <- output[order(output$Group), ]#
#
  return(output)#
}#
#' Calculate overlaps between different groups#
#' #
#' @param input The output of \code{\link{getAreas}}#
#' #
#' @return A list of Overlaps (per timeslot if relevant), as well as the respective overlap rasters.#
#' #
#' @examples #
#' \donttest{#
#' # Import river shapefile#
#' water <- actel::loadShape(path = system.file(package = "RSP"), #
#'  shape = "River_latlon.shp", size = 0.0001, buffer = 0.05) #
#' #
#' # Create a transition layer with 8 directions#
#' tl <- actel::transitionLayer(x = water, directions = 8)#
#' #
#' # Import example output from actel::explore() #
#' data(input.example) #
#' #
#' # Run RSP analysis#
#' rsp.data <- runRSP(input = input.example, t.layer = tl, coord.x = "Longitude", coord.y = "Latitude")#
#' #
#' # Run dynamic Brownian Bridge Movement Model (dBBMM)#
#' dbbmm.data <- dynBBMM(input = rsp.data, base.raster = water, UTM = 56)#
#' #
#' # Get dBBMM areas at group level#
#' areas.group <- getAreas(dbbmm.data, type = "group", breaks = c(0.5, 0.95))#
#' #
#' # Get overlaps between groups#
#' overlap.data <- getOverlaps(areas.group)#
#' }#
#' #
#' @export#
#' #
getOverlaps <- function(input) {#
#
  the.rasters <- input$rasters#
  breaks <- attributes(input)$breaks#
#
  if (length(the.rasters) == 1) #
    stop("Only one group found, overlap calculations cannot be performed.", call. = FALSE)#
#
  if (attributes(input)$area != "group")#
    stop("Overlaps can only be calculated for 'group' areas. Please re-run getAreas with type = 'group'.", call. = FALSE)#
#
  if (attributes(input)$type == "group") {#
    # flatten rasters if needed (i.e. merge all tracks in one raster)#
    # - #
    # HF: This part should now be obsulete since getAreas flattens the #
    # rasters before wrapping up. Keeping it in for now anyway, as it #
    # should be harmless.    #
    the.rasters <- lapply(the.rasters, function(group) {#
      lapply(group, function(limit) {#
        if (class(limit) != "RasterLayer")#
          return(raster::calc(limit, fun = max, na.rm = TRUE))#
        else#
          return(limit)#
      })#
    }) #
#
    # re-structure the list before continuing#
    by.breaks <- lapply(breaks, function(limit) {#
      output <- lapply(the.rasters, function(group) group[[as.character(limit)]])#
    })#
    names(by.breaks) <- breaks#
#
    # start working#
    pb <-  txtProgressBar(min = 0, max = sum(sapply(by.breaks, length)) - length(by.breaks),#
                          initial = 0, style = 3, width = 60)#
    counter <- 0#
    recipient <- lapply(by.breaks, function(limit) {#
      # calculate areas only once#
      areas <- sapply(limit, function(x) sum(raster::values(x), na.rm = TRUE) * raster::xres(x) * raster::yres(x))#
      names(areas) <- names(limit)#
      # prepare recipients for the overlap data#
      overlap.rasters <- list()#
      overlap.matrix.a <- matrix(nrow = length(limit), ncol = length(limit))#
      rownames(overlap.matrix.a) <- colnames(overlap.matrix.a) <- names(limit)#
      overlap.matrix.p <- overlap.matrix.a#
      # compare each elements (except the last) with all the elements coming after it#
      capture <- lapply(1:(length(limit) - 1), function(a) {#
        lapply((a + 1):length(limit), function(b) {#
          # grab the areas calculated before #
          area.a <- areas[a]#
          area.b <- areas[b]#
          if (area.a > 0 & area.b > 0) {#
            # decide who is bigger#
            if (area.a > area.b) {#
              bigger <- limit[[a]]#
              smaller <- limit[[b]]#
            } else {#
              bigger <- limit[[b]]#
              smaller <- limit[[a]]#
            }#
            # match both and calculate overlap#
            raster::extent(smaller) <- raster::extent(bigger)#
            over.raster <- raster::overlay(x = bigger, y = smaller, fun = min)#
            over.area <- sum(raster::values(over.raster), na.rm = TRUE) * raster::xres(over.raster) * raster::yres(over.raster)#
            over.percentage <- over.area / min(area.a, area.b)#
          } else {#
            over.area <- NA#
            over.percentage <- NA#
            over.raster <- NA#
          }#
          # store to environment above#
          overlap.rasters[[length(overlap.rasters) + 1]] <<- over.raster#
          names(overlap.rasters)[[length(overlap.rasters)]] <<- paste0(names(limit)[a], "_and_", names(limit)[b])#
          overlap.matrix.a[names(limit)[a], names(limit)[b]] <<- over.area#
          overlap.matrix.a[names(limit)[b], names(limit)[a]] <<- over.area#
          overlap.matrix.p[names(limit)[a], names(limit)[b]] <<- over.percentage#
          overlap.matrix.p[names(limit)[b], names(limit)[a]] <<- over.percentage#
        })#
        # pass stored information to main function environment before restarting#
        overlap.rasters <<- overlap.rasters#
        overlap.matrix.a <<- overlap.matrix.a#
        overlap.matrix.p <<- overlap.matrix.p#
        counter <<- counter + 1#
        setTxtProgressBar(pb, counter) # Progress bar    #
      })#
      counter <<- counter#
      return(list(overlap.areas = overlap.matrix.a, overlap.percentages = overlap.matrix.p, overlap.rasters = overlap.rasters, areas = areas))#
    })#
    close(pb)#
#
    # simplify the output#
    group.areas <- as.data.frame(sapply(recipient, function(limit) limit$area))#
#
    overlap.rasters <- lapply(recipient, function(limit) limit$overlap.rasters)#
#
    overlap.areas <- lapply(recipient, function(limit) {#
      aux <- limit[1:2]#
      names(aux) <- c("absolute", "percentage")#
      return(aux)#
    })#
  }#
#
  if (attributes(input)$type == "timeslot") {#
#
    # flatten rasters if needed (i.e. merge all tracks in one raster)#
    # - #
    # HF: This part should now be obsulete since getAreas flattens the #
    # rasters before wrapping up. Keeping it in for now anyway, as it #
    # should be harmless.    #
    the.rasters <- lapply(the.rasters, function(group) {#
      lapply(group, function(timeslot) {#
        lapply(timeslot, function(limit) {#
          if (class(limit) != "RasterLayer")#
            return(raster::calc(limit, fun = max, na.rm = TRUE))#
          else#
            return(limit)#
        })#
      })#
    })#
#
    # re-structure the list before continuing#
    by.breaks.by.group <- lapply(breaks, function(limit) {#
      lapply(the.rasters, function(group) {#
        lapply(group, function(timeslot) timeslot[[as.character(limit)]])#
      })#
    })#
    names(by.breaks.by.group) <- breaks#
    # Validate#
    # sum(raster::values(by.breaks.by.group$`0.5`$Brown_Trout1$`25`), na.rm = TRUE)#
    # sum(raster::values(the.rasters$Brown_Trout1$`25`$`0.5`), na.rm = TRUE)#
    # OK#
#
    by.breaks.by.timeslot <- lapply(by.breaks.by.group, function(limit) {#
      all.timeslots <- sort(as.numeric(unique(unlist(lapply(limit, names)))))#
      output <- lapply(all.timeslots, function(timeslot) {#
        lapply(limit, function(group) group[[as.character(timeslot)]])#
      })#
      names(output) <- all.timeslots#
      return(output)#
    })#
    # Validate#
    # sum(raster::values(by.breaks.by.group$`0.5`$Brown_Trout1$`25`), na.rm = TRUE)#
    # sum(raster::values(by.breaks.by.timeslot$`0.5`$`25`$Brown_Trout1), na.rm = TRUE)#
    # OK#
#
    # start working#
    pb <-  txtProgressBar(min = 0, max = sum(sapply(by.breaks.by.timeslot, length)),#
                          initial = 0, style = 3, width = 60)#
    counter <- 0 #
    recipient <- lapply(by.breaks.by.timeslot, function(limit) {#
      output <- lapply(limit, function(timeslot) {#
        # calculate areas only once#
        areas <- sapply(timeslot, function(x) {#
          if (is.null(x)) #
            return(0)#
          else#
            return(sum(raster::values(x), na.rm = TRUE) * raster::xres(x) * raster::yres(x))#
        })#
        # prepare recipients for the overlap data#
        overlap.rasters <- list()#
        overlap.matrix.a <- matrix(nrow = length(timeslot), ncol = length(timeslot))#
        rownames(overlap.matrix.a) <- colnames(overlap.matrix.a) <- names(timeslot)#
        overlap.matrix.p <- overlap.matrix.a#
        # compare each elements (except the last) with all the elements coming after it#
        lapply(1:(length(timeslot) - 1), function(a) {#
          lapply((a + 1):length(timeslot), function(b) {#
            # grab the areas calculated before #
            area.a <- areas[a]#
            area.b <- areas[b]#
            if (area.a > 0 & area.b > 0) {#
              # decide who is bigger#
              if (area.a > area.b) {#
                bigger <- timeslot[[a]]#
                smaller <- timeslot[[b]]#
              } else {#
                bigger <- timeslot[[b]]#
                smaller <- timeslot[[a]]#
              }#
              # match both and calculate overlap#
              raster::extent(smaller) <- raster::extent(bigger)#
              over.raster <- raster::overlay(x = bigger, y = smaller, fun = min)#
              over.area <- sum(raster::values(over.raster), na.rm = TRUE) * raster::xres(over.raster) * raster::yres(over.raster)#
              over.percentage <- over.area / min(area.a, area.b)#
            } else {#
              over.area <- NA#
              over.percentage <- NA#
              over.raster <- NA#
            }#
            # store to environment above#
            overlap.rasters[[length(overlap.rasters) + 1]] <<- over.raster#
            names(overlap.rasters)[[length(overlap.rasters)]] <<- paste0(names(timeslot)[a], "_and_", names(timeslot)[b])#
            overlap.matrix.a[names(timeslot)[a], names(timeslot)[b]] <<- over.area#
            overlap.matrix.a[names(timeslot)[b], names(timeslot)[a]] <<- over.area#
            overlap.matrix.p[names(timeslot)[a], names(timeslot)[b]] <<- over.percentage#
            overlap.matrix.p[names(timeslot)[b], names(timeslot)[a]] <<- over.percentage#
          })#
          # pass stored information to main function environment before restarting#
          overlap.rasters <<- overlap.rasters#
          overlap.matrix.a <<- overlap.matrix.a#
          overlap.matrix.p <<- overlap.matrix.p#
        })#
        counter <<- counter + 1#
        setTxtProgressBar(pb, counter) # Progress bar    #
        return(list(overlap.areas = overlap.matrix.a, overlap.percentages = overlap.matrix.p, overlap.rasters = overlap.rasters, areas = areas))#
      })#
      counter <<- counter#
      return(output)#
    })#
    close(pb)#
#
    # simplify the output#
    overlap.rasters <- lapply(recipient, function(limit) {#
      lapply(limit, function(timeslot) timeslot$overlap.rasters)#
    })#
#
    overlap.areas <- lapply(recipient, function(limit) {#
      absolutes <- lapply(limit, function(timeslot) timeslot[[1]])#
      percentage <- lapply(limit, function(timeslot) timeslot[[2]])#
      return(list(absolutes = absolutes, percentage = percentage))#
    })#
  }#
#
  output <- list(areas = overlap.areas, rasters = overlap.rasters)#
  attributes(output)$type <- attributes(input)$type#
  attributes(output)$breaks <- breaks  #
  return(output)#
}#
#' Obtain overlapping data per timeslots#
#' #
#' When a timeslot analysis is performed the overlaps between pairs of tracked groups can be obtained #
#' according to the respective timeslots.#
#' #
#' @param input The output of \code{\link{getOverlaps}}.#
#' @param dbbmm The timeslot output of \code{\link{dynBBMM}}.#
#' @param groups Character vector specifying two groups for obtaining the overlapping data.#
#' @param level The corresponding contour level for obtaining the overlapping data. #
#' #
#' @return A list of areas per track, per group#
#' #
#' @examples #
#' \donttest{#
#' # Import river shapefile#
#' water <- actel::loadShape(path = system.file(package = "RSP"), #
#'  shape = "River_latlon.shp", size = 0.0001, buffer = 0.05) #
#' #
#' # Create a transition layer with 8 directions#
#' tl <- actel::transitionLayer(x = water, directions = 8)#
#' #
#' # Import example output from actel::explore() #
#' data(input.example) #
#' #
#' # Run RSP analysis#
#' rsp.data <- runRSP(input = input.example, t.layer = tl, coord.x = "Longitude", coord.y = "Latitude")#
#' #
#' # Run a timeslot dynamic Brownian Bridge Movement Model (dBBMM) #
#' dbbmm.data <- dynBBMM(input = rsp.data, base.raster = water, UTM = 56, timeframe = 12)#
#'#
#' # Get dBBMM areas at group level#
#' areas.group <- getAreas(dbbmm.data, type = "group", breaks = c(0.5, 0.95))#
#' #
#' # Get overlaps between groups#
#' overlap.data <- getOverlaps(areas.group)#
#' #
#' # Obtain overlap data at the 50% contour #
#' df.overlap <- getOverlapData(input = overlap.data, dbbmm = dbbmm.data, #
#'  groups = c("G1", "G2"), level = 0.5)#
#' }#
#' #
#' @export#
#' #
getOverlapData <- function(input, dbbmm, groups, level) {#
#
  if (length(groups) != 2)#
    stop("Please specify two groups for obtaining the overlapping data.", call. = FALSE)#
#
  if (length(which(names(input$areas) == level)) == 0)#
    stop("The contour level specified was not found in the overlap object.", call. = FALSE)#
#
  group1 <- groups[1]#
  group2 <- groups[2]#
  input <- input$areas[[which(names(input$areas) == level)]]#
#
  # Absolute overlaps:#
  input.abs <- input[[1]]#
  save.abs <- NULL#
  save.slot <- NULL#
  for (i in 1:length(input.abs)) {#
    save.slot <- c(save.slot, names(input.abs)[[i]])#
    aux <- input.abs[[i]]#
    aux <- aux[which(colnames(aux) == group1), which(row.names(aux) == group2)]#
    save.abs <- c(save.abs, aux)#
  }#
#
  # Percentage overlaps:#
  input.per <- input[[2]]#
  save.per <- NULL#
  for (i in 1:length(input.per)) {#
    aux <- input.per[[i]]#
    aux <- aux[which(colnames(aux) == group1), which(row.names(aux) == group2)]#
    save.per <- c(save.per, aux)#
  }#
#
  # Save final dataset:#
  df.save <- dbbmm$timeslots#
  df.save <- df.save[df.save$slot %in% save.slot, ]#
  df.save$Absolute <- save.abs#
  df.save$Percentage <- save.per#
  names(df.save)[4] <- paste0("Absolute_", group1, "_", group2)#
  names(df.save)[5] <- paste0("Percentage_", group1, "_", group2)#
#
  return(df.save)#
}
# Add variables for animation function:#
utils::globalVariables(c("Latitude", #
  "Longitude", #
  "Timestamp",#
  "Group",#
  "Transmitter",#
  "Signal_Track",#
  "alpha",#
  "%>%"))
#' Identify potential fine-scale data for analysis#
#' #
#' Identifies fine-scale data among total detection dataset to be used for RSP estimation. Tracks are #
#' then named based on the interval between consecutive detection dates.#
#'#
#' @param detections Detections data frame#
#' @param max.time Temporal lag in hours to be considered for the fine-scale tracking. Default is to consider 1-day intervals.#
#' @param recaptures If the recapture locations will be included in the analysis.#
#' @param tz Time zone of the study area.#
#' #
#' @return A dataframe with identified and named individual tracks for RSP estimation.#
#' #
nameTracks <- function(detections, max.time = 24, recaptures, tz) {#
  # Assign tracks to detections#
  if (recaptures == FALSE)#
      breaks <- which(detections$Time.lapse.min > max.time * 60)#
#
  if (recaptures == TRUE) {#
    recap <- read.csv("recaptures.csv")#
    if (detections$Signal[1] %in% recap$Signal) {#
      aux.recap <- recap[which(recap$Signal == detections$Signal[1]), ] #
      detections.aux <- detections[1:nrow(aux.recap), ] # Auxiliar to merge recaptures to detection data!#
      detections.aux$Receiver <- NA#
      detections.aux$Standard.name <- "Recapture"#
      detections.aux$Position <- "Recapture"#
      detections.aux$Error <- min(detections$Error) # Reset to minimum default error!#
      detections.aux$Array <- NA#
      detections.aux$Latitude <- aux.recap$Latitude#
      detections.aux$Longitude <- aux.recap$Longitude#
      detections.aux$Timestamp <- as.POSIXct(aux.recap$Recapture.date, format = "%Y-%m-%d %H:%M:%S", tz = tz) #
      detections.aux$Date <- as.Date(detections.aux$Timestamp)#
      detections <- rbind(detections, detections.aux)#
      detections <- detections[order(detections$Timestamp), ]#
      detections$Time.lapse.min <- c(0, as.numeric(difftime(detections$Timestamp[-1], detections$Timestamp[-nrow(detections)], units = "mins")))#
      breaks <- which(detections$Time.lapse.min > max.time * 60 | detections$Position == "Recapture")#
    } else {#
      breaks <- which(detections$Time.lapse.min > max.time * 60)#
    }#
  }#
  starts <- c(1, breaks)#
  stops  <- c(breaks, nrow(detections) + 1)#
  n <- (stops - starts)#
  track.index <- paste0("Track_", unlist(lapply(1:length(n), function(i) {#
    stringr::str_pad(string = rep(i, n[i]), width = nchar(length(n)), pad = "0")#
  })))#
  detections$Track <- track.index#
#
  # Create tracks summary#
  aux <- split(detections, detections$Track)#
  track.aux <- lapply(aux, function(x) {#
    data.frame(Track = NA_character_,#
      original.n = nrow(x),#
      new.n = nrow(x),#
      First.time = x$Timestamp[1],#
      Last.time = x$Timestamp[nrow(x)],#
      Timespan = difftime(x$Timestamp[nrow(x)], x$Timestamp[1], units = "hours"),#
      Valid = nrow(x) > 1#
      )#
  })#
  tracks <- data.table::rbindlist(track.aux)#
  tracks$Track <- names(aux)#
#
  if (any(!tracks$Valid)) {#
    invalid.tracks <- tracks$Track[which(!tracks$Valid)]#
    detections$Valid[grepl(paste(invalid.tracks, collapse = "|"), detections$Track)] <- FALSE#
  }#
#
  return(list(detections = detections, tracks = tracks))#
}#
#' Prepare detection data for RSP calculations#
#' #
#' Open and sort the detections dataset for applying RSP estimation, using the tagging data to assign #
#' species names and indexes for each tracked animal. #
#' #
#' @param detections A list of detections provided by an actel function.#
#' @param spatial A list of spatial objects in the study area#
#' @inheritParams runRSP#
#' #
#' @return A standardised data frame to be used for RSP calculation. #
#' #
prepareDetections <- function(detections, spatial, coord.x, coord.y) {#
  if (!any(colnames(spatial$stations) == "Range")) #
    warning("Could not find a 'Range' column in the spatial data; assuming a range of 500 metres for each receiver.", immediate. = TRUE, call. = FALSE)#
#
  output <- lapply(names(detections), function(i){#
    x <- detections[[i]]#
    if (length(unique(x$Transmitter)) > 1)#
      x$Transmitter <- rep(i, nrow(x))#
    x$Date <- as.Date(x$Timestamp)#
    if (any(colnames(spatial$stations) == "Range")) {#
      link <- match(x$Standard.name, spatial$stations$Standard.name)#
      x$Error <- spatial$stations$Range[link]#
    } else {#
      x$Error <- 500#
    }#
    x$Time.lapse.min <- c(0, as.numeric(difftime(x$Timestamp[-1], x$Timestamp[-nrow(x)], units = "mins")))#
    x$Longitude <- spatial$stations[[coord.x]][match(x$Standard.name, spatial$stations$Standard.name)]#
    x$Latitude <- spatial$stations[[coord.y]][match(x$Standard.name, spatial$stations$Standard.name)]#
    x$Position <- "Receiver"#
    return(x)#
  })#
  names(output) <- names(detections)#
  return(output)#
}#
#
#' Forcefully round a number up#
#'#
#' Forces the rounding of the input to the next higher rounded value.#
#' #
#' Copied from \link[actel]{actel}#
#' #
#' @param input The value to be rounded.#
#' @param to The level of rounding to be applied (i.e. to=10 will round 14.2 to 20; to=1 will round i to 15).#
#' #
#' @return The rounded value#
#' #
#' @keywords internal#
#' #
roundUp <- function(input, to = 10) {#
  if (inherits(input, "list"))#
    lapply(input, function(input) to * (input %/% to + as.logical(input %% to)))#
  else#
    to * (input %/% to + as.logical(input %% to))#
}#
#' Forcefully round a number down#
#'#
#' Forces the rounding of the input to the next lower rounded value.#
#' #
#' @param input The value to be rounded.#
#' @param to The level of rounding to be applied (i.e. to=10 will round 14.8 to 10; to=1 will round i to 14).#
#' #
#' @return The rounded value#
#' #
#' @keywords internal#
#' #
roundDown <- function(input, to = 10) {#
  to * (input%/%to)#
}
#' @import stats#
#' @import utils#
#' @import graphics#
#' @import data.table#
#' #
NULL#
#
#' Calculate refined shortest paths between detections#
#' #
#' Estimates the RSP for a series of animals tracked with acoustic transmitters. Intermediate#
#' locations between consecutive acoustic detections (either on the same or different receivers) are estimated #
#' according to the defined \code{distance} and \code{time.step} arguments. The error of estimated locations increase proportionally as #
#' the animal moves away from the first detection, and decreases as it approaches the second detection (argument \code{er.ad}). If #
#' the animal is not detected for a long time (default is a daily absence), the detections are broken into a #
#' new track (argument \code{max.time}). #
#'#
#' @param input The output of one of \code{\link[actel]{actel}}'s main functions (\code{\link[actel]{explore}}, \code{\link[actel]{migration}} or \code{\link[actel]{residency}})#
#' @param t.layer A transition layer. Can be calculated using the function \code{\link[actel]{transitionLayer}}.#
#' @param coord.x,coord.y The names of the columns containing the x and y positions of the stations in the spatial object. #
#' @param distance Distance (in metres) by which RSP point should be spaced (between detections at different stations). Defaults to 250 metres.#
#' @param recaptures Logical: if TRUE, a recapture.csv dataset containing the recapture locations of tracked animals will be included in the analysis.#
#' @param time.step Time lapse (in minutes) between RSP points added between detections at the same station. Defaults to 10 minutes. Must not be larger than \code{min.time}.#
#' @param er.ad Increment rate of the position errors for the estimated locations (in metres). If left unset, defaults to 5\% of the \code{distance} argument.#
#' @param min.time Minimum time required between receiver detections (in minutes) for RSP to be calculated. Default to 10 minutes.#
#' @param max.time Maximum time allowed between receiver detections (in hours) for RSP to be calculated. Defaults to 24 hours.#
#' @param debug Logical: If TRUE, the function progress is saved to an RData file.#
#' @param verbose Logical: If TRUE, detailed messages and progression are displayed. Otherwise, a single progress bar is shown.#
#' @param tags Vector of transmitters for which to calculate RSP. By default all transmitters will be analysed.#
#' #
#' @return Returns a list of RSP tracks for each transmitter detected, as well as auxiliary information.#
#' #
#' @examples #
#' \donttest{#
#' # Import river shapefile#
#' water <- actel::loadShape(path = system.file(package = "RSP"), #
#'  shape = "River_latlon.shp", size = 0.0001, buffer = 0.05) #
#' #
#' # Create a transition layer with 8 directions#
#' tl <- actel::transitionLayer(x = water, directions = 8)#
#' #
#' # Import example output from actel::explore() #
#' data(input.example) #
#' #
#' # Run RSP analysis#
#' rsp.data <- runRSP(input = input.example, t.layer = tl, coord.x = "Longitude", coord.y = "Latitude")#
#' }#
#' #
#' @export#
#' #
runRSP <- function(input, t.layer, coord.x, coord.y, distance = 250, tags, recaptures = FALSE,#
  time.step = 10, min.time = 10, max.time = 24, er.ad, verbose = FALSE, debug = FALSE) {#
#
  if (debug) {#
    on.exit(save(list = ls(), file = "RSP_debug.RData"), add = TRUE)#
    message("!!!--- Debug mode has been activated ---!!!")#
  } #
#
  if (is.null(input$rsp.info))#
    stop("'input' could not be recognised as an actel analysis result.\n", call. = FALSE)#
#
  if (missing(er.ad)) #
    er.ad <- distance * 0.05#
#
  if (time.step > min.time)#
    warning("'time.step' should not be larger than 'min.time'.", call. = FALSE, immediate. = TRUE)#
#
  if (recaptures == TRUE) {#
    if ("recaptures.csv" %in% list.files()){#
      recap <- read.csv("recaptures.csv")#
    } else {#
      stop("Missing 'recaptures.csv' file. Please provide the data or set recaptures = FALSE")#
    }#
  }#
#
  message("M: Calculating RSP for the '", input$rsp.info$analysis.type, "' data compiled on ", input$rsp.info$analysis.time)#
#
  # Unpack study data#
  detections <- input$valid.detections#
  spatial <- input$spatial#
  tz <- input$rsp.info$tz#
#
  if (!missing(tags)) {#
    if(any(link <- is.na(match(tags, names(detections)))))#
      stop("Could not find tag(s) ", paste(tags[link], collapse = ", ") , " in the detection data.", call. = FALSE)#
#
    detections <- detections[match(tags, names(detections))]#
  }#
#
  # RSP related changes#
  detections <- prepareDetections(detections = detections, #
    spatial = spatial, coord.x = coord.x, coord.y = coord.y)#
#
  RSP.time <- system.time(recipient <- includeRSP(detections = detections, transition = t.layer, max.time = max.time, min.time = min.time, recaptures = recaptures,#
                                           tz = tz, distance = distance, time.step = time.step, er.ad = er.ad, verbose = verbose, debug = debug))#
  rsp.detections <- recipient$output#
  tracks <- recipient$tracks#
#
  if (debug)#
    print(RSP.time)#
#
  message("M: Percentage of detections valid for RSP: ",#
    round(sum(unlist(lapply(rsp.detections, function(x) sum(x$Position == "Receiver")))) / sum(unlist(lapply(detections, nrow))) * 100, 1), "%")#
  attributes(spatial)$spatial_columns <- c(coord.x, coord.y)#
  return(list(detections = rsp.detections, tracks = tracks, spatial = spatial, bio = input$rsp.info$bio, tz = tz, crs = raster::crs(t.layer)))#
}#
#' Recreating RSP for a particular tracked animal#
#' #
#' Estimates the RSP individually for all tracks of a particular animal.#
#'#
#' @param df.track Detection data for that individual as imported using RSPete.#
#' @param tz Time zone of the study area.#
#' @param distance Maximum distance between RSP locations.#
#' @param time.step Time lapse in minutes to be considered for consecutive detections at the same station. #
#' @param transition TransitionLayer object as returned by LTDpath.#
#' @param er.ad Incremental error per additional RSP point.#
#' @param path.list A list of previously calculated paths.#
#' @inheritParams runRSP#
#' #
#' @return A dataframe with the RSP estimations for all identified tracks for that animal.#
#' #
#' #
calcRSP <- function(df.track, tz, distance, min.time, time.step, transition, er.ad, path.list, verbose) {#
  aux.RSP <- as.data.frame(df.track[-(1:.N)]) # Save RSP#
#
  station.shifts <- c(FALSE, df.track$Standard.name[-1] != df.track$Standard.name[-nrow(df.track)])#
  time.shifts <- df.track$Time.lapse.min > min.time#
  different.station.shift <- station.shifts & time.shifts#
  same.station.shift <- !station.shifts & time.shifts#
#
  if (verbose) #
    pb <- txtProgressBar(min = 0, max = nrow(df.track),#
                              initial = 0, style = 3, width = 60)#
#
  # Add intermediate positions to the RSP track:#
  for (i in 2:nrow(df.track)) {#
    if (verbose)#
      setTxtProgressBar(pb, i) # Progress bar#
    if (same.station.shift[i]) {      #
      # Number of intermediate positions to add:#
      intermediate.points <- as.integer(df.track$Time.lapse.min[i] / time.step)#
    } #
    if (different.station.shift[i]) {#
      A <- with(df.track, c(Longitude[i - 1], Latitude[i - 1]))#
      B <- with(df.track, c(Longitude[i], Latitude[i]))#
      path.name <- paste0("from", paste0(A[1], B[1]), "to", paste0(A[2], B[2]))#
      if (any(names(path.list) == path.name)) {#
        AtoB.df <- path.list[[path.name]]#
      } else {#
        # definitive AtoB's#
        AtoB <- gdistance::shortestPath(transition, A, B, output = "SpatialLines")#
        AtoB.spdf <- suppressWarnings(methods::as(AtoB, "SpatialPointsDataFrame"))#
        AtoB.df <- suppressWarnings(methods::as(AtoB.spdf, "data.frame")[, c(4, 5)]) #
        # wgs84 version just for distance calcs#
        AtoB.wgs84 <- sp::spTransform(AtoB, "+init=epsg:4326")#
        AtoB.wgs84.spdf <- suppressWarnings(methods::as(AtoB.wgs84, "SpatialPointsDataFrame")) #
        AtoB.wgs84.df <- suppressWarnings(methods::as(AtoB.wgs84.spdf, "data.frame")[, c(4, 5)]) #
        colnames(AtoB.wgs84.df) <- c("x", "y")#
        # Prepare to calculate distance between coordinate pairs#
        start <- AtoB.wgs84.df[-nrow(AtoB.df), ]#
        stop <- AtoB.wgs84.df[-1, ]#
        aux <- cbind(start, stop)#
        # Distance in meters#
        AtoB.df$Distance <- c(0, apply(aux, 1, function(m) geosphere::distm(x = m[1:2], y = m[3:4])))#
        rm(AtoB.wgs84, AtoB.wgs84.df, AtoB.wgs84.spdf)#
        # Cumulative distance#
        AtoB.df$cumSum <- cumsum(AtoB.df$Distance)#
        AtoB.dist <- sum(AtoB.df$Distance)#
        # Prepare to find points to keep#
        n.points <- roundDown(AtoB.dist / distance, to = 1)#
        if (n.points == 0) {#
          if (verbose) {#
            message("")#
            warning("One of the inter-station RSP segments within ", df.track$Track[1], #
                    " is too short to fit extra \n   detections (Total distance: ", round(AtoB.dist, 0), #
                    "m). Adding one single point between detections.", immediate. = TRUE, call. = FALSE)#
          }#
          n.points <- 1#
          markers <- AtoB.dist / 2#
        } else {#
          markers <- seq(from = distance, to = distance * n.points, by = distance)#
        }#
        # Find rows closest to markers#
        rows.to.keep <- sapply(markers, function(x) which.min(abs(AtoB.df$cumSum - x)))#
        AtoB.df <- AtoB.df[rows.to.keep, c(1, 2, 4)]#
        # Save condensed data frame for later use#
        path.list[[length(path.list) + 1]] <- AtoB.df#
        names(path.list)[length(path.list)] <- path.name#
      }#
      intermediate.points <- nrow(AtoB.df)#
    }#
    if (exists("intermediate.points")) {#
      # Auxiliar dataset to save intermediate positions:#
      mat.aux <- as.data.frame(df.track[-(1:.N)])#
      # Add intermediate timeframe#
      time.increment <- df.track$Time.lapse.min[i] * 60 / (intermediate.points + 1)#
      baseline <- df.track$Timestamp[i - 1] # Base timeframe#
      incremented.baseline <- baseline#
      if (intermediate.points == 1) {#
          incremented.baseline <- baseline + (as.numeric(difftime(df.track$Timestamp[i], df.track$Timestamp[i - 1], units = "secs"))/ 2)#
          mat.aux[1, "Timestamp"] <- incremented.baseline#
        }#
#
      if (intermediate.points > 1) {#
        for (pos2 in 1:intermediate.points) {#
          incremented.baseline <- incremented.baseline + time.increment#
          mat.aux[pos2, "Timestamp"] <- incremented.baseline#
        }#
        if (mat.aux$Timestamp[nrow(mat.aux)] == df.track$Timestamp[i])#
        mat.aux <- mat.aux[-nrow(mat.aux), ]#
      } #
#
      # Add timelapse for RSP#
      mat.aux$Time.lapse.min[1] <- as.numeric(difftime(mat.aux$Timestamp[1], df.track$Timestamp[i - 1], units = "mins"))#
      if(nrow(mat.aux) > 1)#
        mat.aux$Time.lapse.min[2:nrow(mat.aux)] <- as.numeric(difftime(mat.aux$Timestamp[-1], mat.aux$Timestamp[-nrow(mat.aux)], units = "mins"))#
      # Correct timelapse for receiver detection#
      df.track$Time.lapse.min[i] <- as.numeric(difftime(df.track$Timestamp[i], mat.aux$Timestamp[nrow(mat.aux)], units = "mins"))#
      base <- df.track$Error[i]#
      if (nrow(mat.aux) <= 2) {#
        mat.aux$Error <- base + er.ad #
      } else {#
        med.point <- roundUp(nrow(mat.aux) / 2, to = 1)          #
        incremented.base <- base#
        # Increasing error#
        for (pos2 in 1:med.point) { #
          incremented.base <- incremented.base + er.ad#
          mat.aux$Error[pos2] <- incremented.base #
        }#
        # Fail safe for even intermediate points#
        if (nrow(mat.aux) %% 2 == 0) {#
          mat.aux$Error[med.point + 1] <- incremented.base#
          start.decreasing <- med.point + 2#
        } else {#
          start.decreasing <- med.point + 1#
        }#
        # Decreasing error#
        for (pos2 in start.decreasing:nrow(mat.aux)) { #
          incremented.base <- incremented.base - er.ad#
          mat.aux$Error[pos2] <- incremented.base #
        }#
      }#
      # Repeat data from detected station#
      mat.aux$CodeSpace <- df.track$CodeSpace[i]#
      mat.aux$Signal <- df.track$Signal[i]#
      mat.aux$Transmitter <- df.track$Transmitter[i]#
      mat.aux$Track <- df.track$Track[i]#
      # Fit in remaining variables#
      if (same.station.shift[i]) {#
        mat.aux$Latitude <- df.track$Latitude[i]#
        mat.aux$Longitude <- df.track$Longitude[i]#
      } else {#
        mat.aux$Latitude <- AtoB.df$y#
        mat.aux$Longitude <- AtoB.df$x#
        if (exists("AtoB"))#
          rm(AtoB.df, AtoB, AtoB.spdf)#
        else#
          rm(AtoB.df)#
      }#
      mat.aux$Date <- as.Date(mat.aux$Timestamp, tz = tz)#
      mat.aux$Position <- "RSP"#
      aux.RSP <- rbind(aux.RSP, mat.aux) # Save RSP#
      rm(intermediate.points)#
    }#
  }#
  if (verbose)#
    close(pb)#
#
  tracks.save <- rbind(aux.RSP, df.track)#
  tracks.save <- tracks.save[order(tracks.save$Timestamp), ]#
  row.names(tracks.save) <- 1:nrow(tracks.save)#
  return(list(output = tracks.save, path.list = path.list))#
}#
#' Recreating RSP for all tracked animals#
#' #
#' Automatically estimates the RSP for all tracked individuals within a particular study area. #
#'#
#' @param detections Detection data for that individual as imported using RSPete.#
#' @param transition TransitionLayer object as returned by LTDpath.#
#' @param tz Timezone of the study area.#
#' @param recaptures If the recapture locations will be included in the analysis.#
#' @inheritParams runRSP#
#' #
#' @return A list with the RSP estimations of individual tracks per transmitter.#
#' #
includeRSP <- function(detections, transition, tz, distance, time.step, er.ad, min.time, max.time, verbose, debug = FALSE, recaptures) {#
  if (debug)#
    on.exit(save(list = ls(), file = "includeRSP_debug.RData"), add = TRUE)#
  path.list <- list() # Empty list to save already calculated paths#
#
  if (!verbose)#
      pb <- txtProgressBar(min = 0, max = length(detections),#
                            initial = 0, style = 3, width = 60)#
#
  # Recreate RSP individually#
  aux <- lapply(seq_along(detections), function(i) {#
    if (verbose)#
      message(crayon::bold(crayon::green((paste("Analysing:", names(detections)[i])))))#
    flush.console()#
    recipient <- nameTracks(detections = detections[[i]], max.time = max.time, recaptures = recaptures, tz = tz) # Fine-scale tracking#
    detections[[i]] <<- recipient$detections#
    tracks <- recipient$tracks#
    track.aux <- split(detections[[i]], detections[[i]]$Track)#
#
    tag.aux <- lapply(which(tracks$Valid), function(j) {#
      if (verbose)#
        message("Estimating ", names(detections)[i], " RSP: ", names(track.aux)[j])#
      flush.console()#
      # Recreate RSP#
      df.track <- track.aux[[j]]#
      df.track$Time.lapse.min <- c(0, as.numeric(difftime(df.track$Timestamp[-1], df.track$Timestamp[-nrow(df.track)], units = "mins")))#
      function.recipient <- calcRSP(df.track = df.track, tz = tz, distance = distance, verbose = verbose, min.time = min.time,#
                                    time.step = time.step, transition = transition, er.ad = er.ad, path.list = path.list)#
      # return path.list directly to environment above#
      path.list <<- function.recipient$path.list#
#
      # return rest to lapply list#
      return(function.recipient$output)#
    })#
    # update track n#
    tracks$new.n[which(tracks$Valid)] <- sapply(tag.aux, nrow)#
#
    # combine tracks#
    tag.recipient <- as.data.frame(data.table::rbindlist(tag.aux))#
#
    # pass path.list to main envir.#
    path.list <<- path.list#
#
    # Convert variables to factors#
    tag.recipient$Position <- as.factor(tag.recipient$Position)#
    tag.recipient$Track <- as.factor(tag.recipient$Track)#
    tag.recipient$Receiver <- as.factor(tag.recipient$Receiver)#
    tag.recipient$Transmitter <- as.factor(tag.recipient$Transmitter)#
    tag.recipient$Standard.name <- as.factor(tag.recipient$Standard.name)#
    tag.recipient <- tag.recipient[order(tag.recipient$Timestamp), ]#
#
    if (!verbose)#
      setTxtProgressBar(pb, i) # Progress bar#
#
    return(list(detections = tag.recipient, tracks = tracks))#
  })#
  if (!verbose)#
    close(pb)    #
  output <- lapply(aux, function(x) x$detections)#
  tracks <- lapply(aux, function(x) x$tracks)#
  names(output) <- names(detections)#
  names(tracks) <- names(detections)#
  return(list(output = output, tracks = tracks))#
}
#' Pipe operator#
#'#
#' See \code{magrittr::\link[magrittr:pipe]{\%>\%}} for details.#
#'#
#' @name %>%#
#' @rdname pipe#
#' @keywords internal#
#' @export#
#' @importFrom magrittr %>%#
#' @usage lhs \%>\% rhs#
#' @param lhs A value or the magrittr placeholder.#
#' @param rhs A function call using the magrittr semantics.#
#' @return The result of calling `rhs(lhs)`.#
NULL
?as.data.drame
?as.data.frame
?getwd()
getwd
getwd()
setwd("..")
getwd()
devtools::check()
devtools::check()
getwd()
devtools::install(build_vignettes = TRUE)
devtools::check()
devtools::install(build_vignettes = TRUE)
library(RSP)
?runRSP
devtools::install(build_vignettes = TRUE)
devtools::check()
devtools::check()
devtools::install.packages(build_vignettes = TRUE)
devtools::install(build_vignettes = TRUE)
devtools::install(build_vignettes = TRUE)
